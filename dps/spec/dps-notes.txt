=======
 Notes
=======
:Date: $Date: 2002/01/30 04:56:54 $
:Revision: $Revision: 1.22 $


To Do
=====

- Complete PEP 258 DPS Generic Implementation Details.

  - Fill in the blanks in API details.

  - Specify the nodes.py internal data structure implementation.

        [Tibs:] Eventually we need to have direct documentation in
        there on how it all hangs together - the DTD is not enough
        (indeed, is it still meant to be correct? [Yes, it is.]).

- Rework PEP 257, separating style from spec from tools, wrt DPS. See
  Doc-SIG from 2001-06-19/20.

- PEP 256:

  - Incorporate "modes" (one or two sets).
  - Draw the framework diagram properly as a graphic (once PEPs
    support graphics !-).

- Document!

  - Modules.

  - DPS nodes (DTD element) semantics:

    - External (public) attributes (node.attributes).
    - Internal attributes (node.*).
    - Linking mechanism.

- Get cracking on the DPS itself!

- Add layout component to framework? Or part of the formatter?

- Add validation? See http://pytrex.sourceforge.net, RELAX NG.

- Incorporate readers/"input modes", using Tony Ibbs' 2001-08-03
  Doc-SIG post 'Suggestions for reST "modes"' as a base.

- Write modules for common transforms. See Transforms_ below.

- Ask Python-dev for opinions (GvR for a pronouncement) on special
  variables (__author__, __version__, etc.): convenience vs. namespace
  pollution. Ask opinions on whether or not the DPS should recognize &
  use them.

- Once doctree.txt is fleshed out, how about breaking (most of) it up
  and putting it into nodes.py as docstrings?

- Refactor:

  - Apply the `coding conventions`_ as given below.


Coding Conventions
==================

This project shall follow the generic coding conventions as specified
in the `Style Guide for Python Code`__ and `Docstring Conventions`__
PEPs, with the following clarifications:

- 4 spaces per indentation level. No tabs.
- No one-liner compound statements (i.e., no ``if x: return``: use two
  lines & indentation), except for degenerate class or method
  definitions (i.e., ``class X: pass`` is O.K.).
- Lines should be no more than 78 or 79 characters long.
- "CamelCase" shall be used for class names.
- Use "lowercase" or "lowercase_with_underscores" for function,
  method, and variable names. For short names, maximum two joined
  words, use lowercase (e.g. 'tagname'). For long names with three or
  more joined words, or where it's hard to parse the split between two
  words, use lowercase_with_underscores (e.g., 'note_explicit_target',
  'explicit_target').

__ http://www.python.org/peps/pep-0008.html
__ http://www.python.org/peps/pep-0257.html


Transforms
==========

Footnote Gathering
------------------

Collect and move footnotes to the end of a document.


Hyperlink Target Gathering
--------------------------

It probably comes in two phases, because in a Python context we need
to *resolve* them on a per-docstring basis [do we? --DG], but if the
user is trying to do the callout form of presentation, they would then
want to group them all at the end of the document.


Reference Merging
-----------------

When merging two or more subdocuments (such as docstrings),
conflicting references may need to be resolved.  There may be:

- duplicate reference and/or substitution names that need to be made
  unique; and
- duplicate footnote numbers that need to be renumbered.

Should this be done before or after reference-resolving transforms
are applied? What about references from within one subdocument to
inside another?


Table of Contents
-----------------

This runs over the entire tree, and locates <section> elements. It
produces a <contents> subtree, which can be inserted at the
appropriate place, with links to the <section>s. It needs to make sure
that the links it uses are *real*, so ideally it will use the
"implicit" link for a section when it exists, and it will have to
invent one when the implicit link isn't there (presumably because the
section is the twelfth "Introduction" in the document...).


Index
-----

@@@


I/O APIs
========

Can we use codecs for this?  Input to parser and output from formatter
are strings, but the intermediate data structure is a DOM tree.


Docstring Extractor
===================

We need code that scans a parsed Python module, and returns an ordered
tree containing the names, docstrings (including attribute and
additional docstrings), and additional info (in parentheses below) of
all of the following objects:

- packages
- modules
- module attributes (+ values)
- classes (+ inheritance)
- class attributes (+ values)
- instance attributes (+ values)
- methods (+ formal parameters & defaults)
- functions (+ formal parameters & defaults)

(Extract comments too? For example, comments at the start of a module
would be a good place for bibliographic field lists.)

In order to evaluate interpreted text cross-references, namespaces for
each of the above will also be required.

See python-dev/docstring-develop thread "AST mining", started on
2001-08-14.


Modes and Styles
================

The Python docstring mode model that's evolving in my mind goes
something like this:

1. Extract the docstring/namespace tree from the module(s) and/or
   package(s).

2. Run the parser on each docstring in turn, producing a forest of
   trees (internal data structure as per nodes.py).

3. Run various transformations on the individual docstring trees.
   Examples: resolving cross-references; resolving hyperlinks;
   footnote auto-numbering; first field list -> bibliographic
   elements.

4. Join the docstring trees together into a single tree, running more
   transformations (such as creating various sections like "Module
   Attributes", "Functions", "Classes", "Class Attributes", etc.; see
   the DPS spec/ppdi.dtd).

5. Pass the resulting unified tree to the output formatter.

I've had trouble reconciling the roles of input parser and output
formatter with the idea of "modes". Does the mode govern the
tranformation of the input, the output, or both? Perhaps the mode
should be split into two.

For example, say the source of our input is a Python module. Our
"input mode" should be "Python Docstring Mode". It discovers (from
``__docformat__``) that the input parser is "reStructuredText". If we
want HTML, we'll specify the "HTML" output formatter. But there's a
piece missing. What *kind* or *style* of HTML output do we want?
PyDoc-style, LibRefMan style, etc. (many people will want to specify
and control their own style). Is the output style specific to a
particular output format (XML, HTML, etc.)? Is the style specific to
the input mode? Or can/should they be independent?

I envision interaction between the input parser, an "input mode"
(would control steps 1, 2, & 3), a "transformation style" (would
control step 4), and the output formatter. The same intermediate data
format would be used between each of these, gaining detail as it
progresses.

This requires thought.

Tony's contribution:

    OK - my model is not dissimilar, but goes like:
    
    1. Parse the Python module(s) [remembering we may have a package]
       This locates the docstrings, amongst other things.
    
    2. Trim the tree to lose stuff we didn't need (!).
    
    3. Parse the docstrings (this might, instead, be done at the time
       that each docstring is "discovered").
    
    4. Integrate the docstring into the tree - this *may* be as simple
       as having "thing.docstring = <docstring instance>"
    
    5. Perform internal resolutions on the docstring (footnotes, etc.)
    
    6. Perform intra-module/package resolutions on the docstring
       (so this is when we work out that `Fred` in *this* docstring
       refers to class Fred over here in the datastructure).
    
    7. Format.

    ...

    A mode needs to:
    
    1. Provide plugins for parsing - this *may* go so far as to
       subsume the DPS functionality into a new program, as I'm doing
       for Python. In this case the "plugin" for parsing may be
       virtual - I just need to ferret around in the docstring looking
       for things that are already there, perhaps.
    
    2. Provide plugins for formatting - again, these may subsume a
       DPS parser process. In the Python case, I clearly want to *use*
       the normal HTML parser for HTML output, but with extra support
       "around it" for the Python specific infrastructure.


Visitors
========

To nodes.py, add ``Node.walkabout()``, ``Visitor.walkabout()``,
``Visitor.leave_*()``, and ``GenericVisitor.default_leave()`` methods
to catch elements on the way out? Here's ``Node.walkabout()``::

    def walkabout(self, visitor, ancestry=()):
        """
        Traverse a tree of `Node` objects. Call `visitor`'s
        ``visit_...`` method (upon initial entry) **and** its
        ``leave_...`` method (before exiting).

        Parameters:

        - `visitor`: A `Visitor` object, containing a ``visit_...``
          and ``leave_...`` method for each `Node` subclass
          encountered.
        - `ancestry`: A list of (parent, index) pairs. `self`'s parent
          is the last entry.
        """
        method = getattr(visitor, 'visit_' + self.__class__.__name__)
        method(self, ancestry)
        children = self.getchildren()
        for i in range(len(children)):
            children[i].walkabout(visitor, ancestry + ((self, i),))
        method = getattr(visitor, 'leave_' + self.__class__.__name__)
        method(self, ancestry)

Here's ``Visitor.walkabout()``::

    def walkabout(self):
        self.doctree.walkabout(self)


Mixing Automatic and Manual Footnote Numbering
==============================================

[David]
I'm re-examining (for validity) what I wrote in the spec:

    Automatic footnote numbering may not be mixed with manual footnote
    numbering; it would cause numbering and referencing conflicts.

Would such mixing inevitably cause conflicts? We could probably work around
potential conflicts with a decent algorithm. Should we? Requires thought.
Opinions?

[Tony]
Well, I read that paragraph in the documentation, and decided that it
was in the category of "don't, in practice, care" so far as I was
concerned. This is the same category I put the forbidding of nested
inline markup - quite clearly one *can* do it, but equally clearly it's
a pain to implement, and not a terribly great gain, all things
considered.

It's a category with the subtext "examine for correctness after we've
had some experience of people *using* reST in the wild".

Thus, given there are lots of other things to do, I would tend to leave
it as-is (especially if you are able to *warn* people about it if they
do it by mistake).

To my mind, being able to do ``[#thing]_`` probably give people enough
precision over footnotes whils still allowing autonumbering - the *only*
potential problem is when referring to a footnote in a different
document (and that, again, is something I would leave fallow for the
moment, although we know I tend to want to use roles as annotation for
that sort of thing).



Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End:
