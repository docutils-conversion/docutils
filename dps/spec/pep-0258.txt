PEP: 258
Title: DPS Generic Implementation Details
Version: $Revision: 1.2 $
Last-Modified: $Date: 2001/08/04 15:43:33 $
Author: dgoodger@bigfoot.com (David Goodger)
Discussions-To: doc-sig@python.org
Status: Draft
Type: Standards Track
Requires: 256, 257
Created: 31-May-2001
Post-History: 13-Jun-2001


Abstract

    This PEP documents generic implementation details for a Python
    Docstring Processing System (DPS).  The rationale and high-level
    concepts of the DPS are documented in PEP 256, "Docstring
    Processing System Framework" [1].

    No changes to the core Python language are required by this PEP.


Specification

    Docstring Extraction Rules
    ==========================

    1. What to examine:

       a) If the '__all__' variable is present in the module being
          documented, only identifiers listed in '__all__' are
          examined for docstrings.

       b) In the absense of '__all__', all identifiers are examined,
          except those whose names are private (names begin with '_'
          but don't begin and end with '__').

       c) 1a and 1b can be overridden by a parameter or command-line
          option.

    2. Where:

       Docstrings are string literal expressions, and are recognized
       in the following places within Python modules:

       a) At the beginning of a module, function definition, class
          definition, or method definition, after any comments.  This
          is the standard for Python __doc__ attributes.

       b) Immediately following a simple assignment at the top level
          of a module, class definition, or __init__ method
          definition, after any comments.  See "Attribute Docstrings"
          below.

       c) Additional string literals found immediately after the
          docstrings in (a) and (b) will be recognized, extracted, and
          concatenated.  See "Additional Docstrings" below.

    3. How:

       Whenever possible, Python modules should be parsed by the
       docstring processing system, not imported.  There are security
       reasons for not importing untrusted code.  Also, docstrings are
       to be recognized in places where the bytecode compiler ignores
       string literal expressions (2b and 2c above), meaning importing
       the module will lose these docstrings.  Of course, standard
       Python parsing tools such as the 'parser' library module may
       be used.

       When the Python source code for a module is not available
       (i.e. only the .pyc file exists) or for C extension modules, to
       access docstrings the module must be imported.

    Since attribute docstrings and additional docstrings are ignored
    by the Python bytecode compiler, no namespace pollution or runtime
    bloat will result from their use.  They are not assigned to
    __doc__ or to any other attribute.  The initial parsing of a
    module may take a slight performance hit.

    Attribute Docstrings
    --------------------

    (This is a simplified version of PEP 224 [2] by Marc-Andre
    Lemberg.)

    A string literal immediately following an assignment statement is
    interpreted by the docstring extration machinery as the docstring
    of the target of the assignment statement, under the following
    conditions:

    1. The assignment must be in one of the following contexts:

       a) At the top level of a module (i.e., not nested inside a
          compound statement such as a loop or conditional): a module
          attribute.

       b) At the top level of a class definition: a class attribute.

       c) At the top level of the '__init__' method definition of a
          class: an instance attribute.

       Since each of the above contexts are at the top level (i.e., in
       the outermost suite of a definition), it may be necessary to
       place dummy assignments for attributes assigned conditionally
       or in a loop.

    2. The assignment must be to a single target, not to a list or a
       tuple of targets.

    3. The form of the target:

       a) For contexts 1a and 1b above, the target must be a simple
          identifier (not a dotted identifier, a subscripted
          expression, or a sliced expression).

       b) For context 1c above, the target must be of the form
          'self.attrib', where 'self' matches the '__init__' method's
          first parameter (the instance parameter) and 'attrib' is a
          simple indentifier as in 3a.

    Blank lines may be used after attribute docstrings to emphasize
    the connection between the assignment and the docstring.

    Examples::

        g = 'module attribute (global variable)'
        """This is g's docstring."""

        class AClass:

            c = 'class attribute'
            """This is AClass.c's docstring."""

            def __init__(self):
                self.i = 'instance attribute'
                """This is self.i's docstring."""

    Additional Docstrings
    ---------------------

    Many programmers would like to make extensive use of docstrings
    for API documentation.  However, docstrings do take up space in
    the running program, so some of these programmers are reluctant to
    'bloat up' their code.  Also, not all API documentation is
    applicable to interactive environments, where __doc__ would be
    displayed.

    The docstring processing system's extraction tools will
    concatenate all string literal expressions which appear at the
    beginning of a definition or after a simple assignment.  Only the
    first strings in definitions will be available as __doc__, and can
    be used for brief usage text suitable for interactive sessions;
    subsequent string literals and all attribute docstrings are
    ignored by the Python bytecode compiler and may contain more
    extensive API information.

    Example::

        def function(arg):
            """This is __doc__, function's docstring."""
            """
            This is an additional docstring, ignored by the bytecode
            compiler, but extracted by the DPS.
            """
            pass

    Issue: This breaks 'from __future__ import' statements in Python
    2.1 for multiple module docstrings.  The Python Reference Manual
    specifies:

        A future statement must appear near the top of the module. The
        only lines that can appear before a future statement are:

        * the module docstring (if any), 
        * comments, 
        * blank lines, and 
        * other future statements. 

    Resolution?

    1. Should we search for docstrings after a __future__ statement?
       Very ugly.

    2. Redefine __future__ statements to allow multiple preceeding
       string literals?

    3. Or should we not even worry about this?  There shouldn't be
       __future__ statements in production code, after all.  Modules
       with __future__ statements will have to put up with the
       single-docstring limitation.

    Choice of Docstring Format
    ==========================

    Rather than force everyone to use a single docstring format,
    multiple input formats are allowed by the processing system.  A
    special variable, __docformat__, may appear at the top level of a
    module before any function or class definitions.  Over time or
    through decree, a standard format or set of formats should emerge.

    The __docformat__ variable is a string containing the name of the
    format being used, a case-insensitive string matching the input
    parser's module or package name (i.e., the same name as required
    to 'import' the module or package), or a registered alias.  If no
    __docformat__ is specified, the default format is 'plaintext' for
    now; this may be changed to the standard format once determined.

    The __docformat__ string may contain an optional second field,
    separated from the format name (first field) by a single space: a
    case-insensitive language identifier as defined in RFC 1766 [4].
    A typical language identifier consists of a 2-letter language code
    from ISO 639 [5] (3-letter codes used only if no 2-letter code
    exists; RFC 1766 is currently being revised to allow 3-letter
    codes).  If no language identifier is specified, the default is
    'en' for English.  The language identifier is passed to the parser
    and can be used for language-dependent markup features.

    DPS Structure
    =============

    - package 'dps'

      - function 'dps.main()' (in 'dps/__init__.py')

      - package 'dps.parsers'

        - module 'dps.parsers.model'; see 'Input Parser API' below.

      - package 'dps.formatters'

        - module 'dps.formatters.model'; see 'Output Formatter API'
          below.

      - package 'dps.languages'

        - module 'dps.languages.en' (English)

        - others to be added

      - utility modules: 'dps.nodes', 'dps.statemachine', 'dps.utils'

    Command-Line Interface
    ======================

    XXX To be determined.

    System Python API
    =================

    XXX To be determined.

    Input Parser API
    ================

    Each input parser is a module or package exporting a 'Parser'
    class, with the following interface:

        class Parser:

            def __init__(self, inputstring, warninglevel=1,
                         errorlevel=3, language='en'):
                """Initialize the Parser instance."""

            def parse(self):
                """Parse the input string and return a tree."""

    XXX This needs a lot of work.  What is required for this API?

    A model 'Parser' class implementing the full interface along with
    utility functions can be found in the 'dps.parsers.model' module.

    Output Formatter API
    ====================

    Each output formatter is a module or package exporting a
    'Formatter' class, with the following interface:

        class Formatter:

            def __init__(self, domtree, language='en',
                         showwarnings=0):
                """Initialize the Formatter instance."""

            def format(self):
                """Return a formatted string from the DOM tree."""

    XXX This also needs a lot of work.  What is required for this API?

    XXX How to handle unimplemented elements?

    A model 'Formatter' class implementing the full interface along
    with utility functions can be found in the 'dps.formatters.model'
    module.

    Language Module API
    ===================

    Language modules will contain language-dependent strings and
    mappings.  They will be named for their language identifier (as
    defined in 'Choice of Docstring Format' above), converting dashes
    to underscores.

    XXX Specifics to be determined.

    Intermediate Data Structure
    ===========================

    A single intermediate data structure is used by the docstring
    processing system, in the interfaces between parsers, the DPS
    itself, and formatters.  It is not required that this data
    structure be used internally by any of the componentes.  This data
    structure is similar to a DOM tree whose schema is documented in
    an XML DTD (eXtensible Markup Language Document Type Definition),
    which comes in three parts:

    - the Python Plaintext Document Interface DTD, ppdi.dtd [6],

    - the Generic Plaintext Document Interface DTD, gpdi.dtd [7],

    - and the OASIS Exchange Table Model, soextbl.dtd [8].

    The DTD defines a rich set of elements, suitable for any input
    syntax or output format.  The input parser and the output
    formatter share the same intermediate data structure.  The
    processing system may do transformations on the data from the
    input parser before passing it on to the output formatter.  The
    DTD retains all information necessary to reconstruct the original
    input text, or a reasonable facsimile thereof.

    XXX Specifics (about the DOM tree) to be determined.

    Output Management
    =================

    XXX To be determined.

    Type of output: filesystem only, or in-memory data structure too?
    File/directory naming & structure conventions.  In-memory data
    structure should follow filesystem naming; file/directory ==
    leaf/node.  Use a directory hierarchy rather than long file names.
    (The files generated by pythondoc used compound file names, like
    'packagename.modulename.classname.html', which were often too long
    for the 38-character MacOS file name length limit.  This is one of
    the reasons pythondoc couldn't run on MacOS).

    Error Handling
    ==============

    When the parser encounters an error in markup, it inserts a system
    warning (DTD element 'system_warning').  There are four levels of
    system warnings:

    - Level-0, "information": A minor issue that can be ignored.
      There is no effect on the processing. Typically level-0 system
      warnings are not reported.

    - Level-1, "warning": An issue that should be addressed.  If
      ignored, there may be unpredictable problems with the output.

    - Level-2, "error": An error that should be addressed.  If
      ignored, the output will contain errors.

    - Level-3, "severe": A severe error that must be addressed.
      Typically level-3 system warnings are turned into exceptions
      which halt processing.  If ignored, the output will contain
      severe errors.


References and Footnotes

    [1] PEP 256, Docstring Processing System Framework, Goodger
        http://www.python.org/peps/pep-0256.html

    [2] PEP 224, Attribute Docstrings, Lemburg
        http://www.python.org/peps/pep-0224.html

    [3] PEP 257, Docstring Conventions, Goodger, Van Rossum
        http://www.python.org/peps/pep-0257.html

    [4] http://www.rfc-editor.org/rfc/rfc1766.txt

    [5] http://lcweb.loc.gov/standards/iso639-2/englangn.html

    [6] http://docstring.sourceforge.net/spec/ppdi.dtd

    [7] http://docstring.sourceforge.net/spec/gpdi.dtd

    [8] http://docstring.sourceforge.net/spec/soextblx.dtd

    [9] http://www.python.org/sigs/doc-sig/


Project Web Site

    A SourceForge project has been set up for this work at
    http://docstring.sourceforge.net.


Copyright

    This document has been placed in the public domain.


Acknowledgements

    This document borrows ideas from the archives of the Python
    Doc-SIG [9].  Thanks to all members past & present.



Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
sentence-end-double-space: t
End:
