=======================================
 reStructuredText Markup Specification
=======================================
Author: David Goodger
Contact: dgoodger@bigfoot.com
Revision: $Revision: 1.6 $
Date: $Date: 2001/08/06 04:49:18 $

reStructuredText_ is plain text that uses simple and intuitive
constructs to indicate the structure of a document. These constructs
are equally easy to read in raw and processed forms. This document is
itself an example of reStructuredText (raw, if you are reading the
text file, or processed, if you are reading an HTML document, for
example). reStructuredText is a candidate markup syntax for the
`Python Docstring Processing System`_.

Simple, implicit markup is used to indicate special constructs, such
as section headings, bullet lists, and emphasis. The markup used is as
minimal and unobtrusive as possible. Less often-used constructs and
extensions to the basic reStructuredText syntax may have more
elaborate or explicit markup.

reStructuredText is applicable to documents of any length, from the
very small (such as inline program documentation fragments, e.g.
Python docstrings) to the quite large (this document).

The first section gives a quick overview of the syntax of the
reStructuredText markup by example. More details are given in the
`Syntax Details`_ section.

`Literal blocks`_ (in which no markup processing is done) are used for
examples throughout this document, to illustrate the plain text
markup.


-----------------------
 Quick Syntax Overview
-----------------------

A reStructuredText document is made up of body elements, and may be
structured into sections. `Section Structure`_ is indicated through
title style (underlines & optional overlines). Sections contain body
elements and/or subsections.

Here are examples of body elements:

- Paragraphs_ (and `inline markup`_)::

      Paragraphs contain text and may contain inline markup:
      *emphasis*, **strong emphasis**, `interpreted text`, ``inline
      literals``, standalone hyperlinks (http://www.python.org),
      indirect hyperlinks (Python_), internal cross-references
      (example_), footnote references ([1]_).

      Paragraphs are separated by blank lines and are left-aligned.

- Three types of lists:

  1. `Bullet lists`_::

         - This is a bullet list.

         - Bullets can be '-', '*', or '+'.

  2. `Enumerated lists`_::

         1. This is an enumerated list.

         2. Enumerators may be arabic numbers, letters, or roman
            numerals.

  3. `Definition lists`_::

         what
             Definition lists associate a term with a definition.

         how
             The term is a one-line phrase, and the definition is one
             or more paragraphs or body elements, indented relative to
             the term.

- `Literal blocks`_::

      Literal blocks are indented, and indicated with a double-colon
      ('::') at the end of the preceding paragraph::

          if literal_block:
              text = 'is left as-is'
              spaces_and_linebreaks = 'are preserved'
              markup_processing = None

- `Block quotes`_::

      Block quotes consist of indented body elements:

          This theory, that is mine, is mine.

          Anne Elk (Miss)

- Tables_::

      +------------------------+------------+----------+
      | Header row, column 1   | Header 2   | Header 3 |
      +========================+============+==========+
      | body row 1, column 1   | column 2   | column 3 |
      +------------------------+------------+----------+
      | body row 2             | Cells may span        |
      +------------------------+------------+----------+

- Footnotes_::

      .. _[1] A footnote contains indented body elements.

          It is a form of hyperlink target.

- `Hyperlink targets`_::

      .. _Python: http://www.python.org

      .. _example:

      The '_example' target above points to this paragraph.

- Directives_::

      .. graphic:: mylogo.png

- Comments_::

      .. Comments begin with two dots and a space. Anything may
         follow, except for the syntax of footnotes, hyperlink
         targets, and directives, described above.


----------------
 Syntax Details
----------------

Below is a diagram of the hierarchy of element types in
reStructuredText. Elements may contain other elements below them.
Element types in parentheses indicate recursive or one-to-many
relationships: sections may contain (sub)sections, tables contain
further body elements, etc. ::

    +------------------------------------------------------------------+
    | document                                                         |
    |                           +--------------------------------------+
    | [root element]            |                           +-------+  |
    |                           | sections  [begin with one | title |] |
    |                           |                           +-------+  |
    |---------------------------+-------------------------+------------|
    | [body elements:]                                    | (sections) |
    |         |         | - lists  |       | - hyperlink  +------------+
    |         |         | - tables |       |   targets    |
    | para-   | literal | - block  | foot- | - directives |
    | graphs  | blocks  |   quotes | notes | - comments   |
    +---------+---------+----------+-------+--------------+
    | [text]+ | [text]  | (body elements)  | [text]       |
    | (inline +---------+------------------+--------------+
    | markup) |
    +---------+

For definitive element hierarchy details, see the "Generic Plaintext
Document Interface DTD" XML document type definition, gpdi.dtd_.
Descriptions below list 'DTD elements' (XML 'generic identifiers')
corresponding to syntax constructs.


Whitespace
==========

Blank lines are used to separate paragraphs and other elements.
Multiple successive blank lines are equivalent to a single blank line,
except within literal blocks (where all whitespace is preserved).
Blank lines may be omitted when the markup makes element separation
unambiguous, in conjunction with indentation. The first line of a
document is treated as if it is preceded by a blank line, and the
last line of a document is treated as if it is followed by a blank
line.

Indentation is used to indicate, and is only significant in
indicating:

- multiple body elements within a list item (including nested lists),
- the definition part of a definition list item,
- block quotes, and
- the extent of literal blocks.

Any text whose indentation is less than that of the current level
(i.e., unindented text or "dedents") ends the current level of
indentation.

Although spaces are recommended for indentation, tabs may also be
used. Tabs will be converted to spaces. Tab stops are at every 8th
column.


Escaping Mechanism
==================

The character set available in plain text documents, 7-bit ASCII, is
limited. No matter what characters are used for markup, they will
already have multiple meanings in written text. Therefore markup
characters *will* sometimes appear in text **without being intended as
markup**.

Any serious markup system requires an escaping mechanism to override
the default meaning of the characters used for the markup. In
reStructuredText we use the backslash, commonly used as an escaping
character in other domains.

A backslash followed by any character escapes the character. The
escaped character represents the character itself, and is prevented
from playing a role in any markup interpretation. The backslash is
removed from the output. A literal backslash is represented by two
backslashes in a row.

There are two contexts in which backslashes have no special meaning:
literal blocks and inline literals. In these contexts, a single
backslash represents a literal backslash.


Section Structure
=================

DTD elements: section, title.

Sections are identified through their titles, which are marked up with
adornment: 'underlines' below the title text, and, in some cases,
matching 'overlines' above the title. An underline/overline is a line
of non-alphanumeric characters that begins in column 1 and extends at
least as far as the right edge of the title text. An
underline/overline must be at least 3 characters long. When an
overline is used, the length and character used must match the
underline. There may be any number of levels of section titles.

Rather than imposing a fixed number and order of section title
adornment styles, the order enforced will be the order as encountered.
The first style encountered will be an outermost title (like HTML H1),
the second style will be a subtitle, the third will be a subsubtitle,
and so on.

Below are examples of section title styles::

    ===============
     Section Title
    ===============

    ---------------
     Section Title
    ---------------

    Section Title
    =============

    Section Title
    -------------

    Section Title
    `````````````

    Section Title
    '''''''''''''

    Section Title
    .............

    Section Title
    ~~~~~~~~~~~~~

    Section Title
    *************

    Section Title
    +++++++++++++

    Section Title
    ^^^^^^^^^^^^^

When a title has both an underline and an overline, the title text may
be inset, as in the first two examples above. This is merely aesthetic
and not significant. Underline-only title text may not be inset.

A blank line after a title is optional. All text blocks up to the next
title of the same or higher level are included in a section (or
subsection, etc.).

All section title styles need not be used, nor need any specific
section title style be used. However, a document must be consistent in
its use of section titles: once a hierarchy of title styles is
established, sections must use that hierarchy.

Each section title automatically generates a hyperlink target pointing
to the section. The text of the hyperlink target is the same as that
of the section title. See `Implicit Hyperlink Targets`_ for a complete
description.


Body Elements
=============

Paragraphs
----------

DTD element: paragraph.

Paragraphs consist of blocks of left-aligned text with no markup
indicating any other body element. Blank lines separate paragraphs
from each other and from other body elements. Paragraphs may contain
`inline markup`_.

Syntax diagram::

    +------------------------------+
    | paragraph                    |
    |                              |
    +------------------------------+
    +------------------------------+
    | paragraph                    |
    |                              |
    +------------------------------+


Bullet Lists
------------

DTD elements: bullet_list, list_item.

A text block which begins with a '-', '*', or '+', followed by
whitespace, is a bullet list item (a.k.a. 'unordered' list item). For
example::

    - This is the first bullet list item. The blank line above the
      first list item is required; blank lines between list items
      (such as below this paragraph) are optional. Text blocks must be
      left-aligned, indented relative to the bullet.

    - This is the first paragraph in the second item in the list.

      This is the second paragraph in the second item in the list. The
      blank line above this paragraph is required. The left edge of
      this paragraph lines up with the paragraph above, both indented
      relative to the bullet.

      - This is a sublist. The bullet lines up with the left edge of
        the text blocks above. A sublist is a new list so requires a
        blank line above and below.

    - This is the third item of the main list.

    This paragraph is not part of the list.

Here are examples of **incorrectly** formatted bullet lists::

    - This first line is fine.
    A blank line is required between list items and paragraphs.
    (Warning)

    - The following line appears to be a new sublist, but it is not:
      - This is a paragraph contination, not a sublist (since there's
        no blank line). This line is also incorrectly indented.
      - Warnings may be issued by the implementation.

Syntax diagram::

    +------+-----------------------+
    | '- ' | list item             |
    +------| (body elements)+      |
           +-----------------------+


Enumerated Lists
----------------

DTD elements: enumerated_list, list_item.

Enumerated lists (a.k.a. 'ordered' lists) are similar to bullet lists,
but use enumerators instead of bullets. An enumerator consists of an
enumeration sequence member and formatting, followed by whitespace.
The following enumeration sequences are recognized:

- arabic numerals: 1, 2, 3, ... (no upper limit).
- uppercase alphabet characters: A, B, C, ..., Z.
- lower-case alphabet characters: a, b, c, ..., z.
- uppercase Roman numerals: I, II, III, IV, ... (no upper limit).
- lowercase Roman numerals: i, ii, iii, iv, ... (no upper limit).

The following formatting types are recognized:

- suffixed with a period: '1.', 'A.', 'a.', 'I.', 'i.'.
- surrounded by parentheses: '(1)', '(A)', '(a)', '(I)', '(i)'.
- suffixed with a right-parenthesis: '1)', 'A)', 'a)', 'I)', 'i)'.

A system warning will be generated for each of the following cases:

1. The enumerators do not all have the same format and sequence type. 

2. The enumerators are not in sequence (i.e., '1.', '3.' is not
   allowed).

It is recommended that the enumerator of the first list item be
ordinal-1 ('1', 'A', 'a', 'I', or 'i'). Although other start-values
will be recognized, they may not be supported by the output format.

Nested enumerated lists must be created with indentation. For
example::

    1. Item 1.

       a) item 1a.
       b) Item 1b.

Syntax diagram::

    +-------+----------------------+
    | '1. ' | list item            |
    +-------| (body elements)+     |
            +----------------------+


Definition Lists
----------------

DTD elements: definition_list, definition_list_item, term, definition.

Each definition list item contains a term and a definition. A term is
a simple one-line paragraph. A definition is a block indented relative
to the term, and may contain multiple paragraphs and other body
elements. Blank lines are required before the term and after the
definition, but there may be no blank line between a term and a
definition (this distinguishes definition lists from `block quotes`_).
::

    term 1
        Definition 1.

    term 2
        Definition 2, paragraph 1.

        Definition 2, paragraph 2.

Syntax diagram::

    +------+
    | term |
    +--+---+-----------------------+
       | defninition               |
       | (body elements)+          |
       +---------------------------+


Field Lists
-----------

DTD elements: field_list, field, field_name, field_argument,
field_body.

    Syntax under construction. Comments and suggestions welcome.

Field lists are mappings from field names to field bodies, modeled on
RFC822_ headers. A field name is made up of one or more letters,
numbers, and punctuation, except colons (':') and whitespace. Field
names are case-insensitive. A single colon and whitespace follows the
field name, and this is followed by the field body. The field body may
contain multiple body elements.

    Why is RFC822 compliance important? It's a universal Internet
    standard, and super obvious. Also, I'd like to support the PEP
    format (ulterior motive: get PEPs to use reStructuredText as their
    standard). But it *would* be easy to get used to an alternative
    (easy even to convert PEPs; probably harder to convert
    python-deviants ;-).

    Unfortunately, without well-defined context (such as in email
    headers: RFC822 applies before any blank lines only), the RFC822
    format is very common in ordinary text. To implement field lists
    unambiguously, we need explicit syntax.

Applications of reStructuredText may recognize field names and
transform fields or field bodies in certain contexts. Any
untransformed fields remain in the field list as the document's first
body element.

The syntax for field lists has not been finalized. Syntax
alternatives:

1. Unadorned RFC822_ everywhere::

       Author: Me
       Version: 1

   Advantages: clean, precedent (RFC822-compliant). Disadvantage:
   ambiguous (these paragraphs are a prime example).

   Conclusion: rejected.

2. Special case: use unadorned RFC822_ for the very first or very last
   text block of a document::

       """
       Author: Me
       Version: 1

       The rest of the document...
       """

   Advantages: clean, precedent (RFC822-compliant). Disadvantages:
   special case, flat (unnested) field lists only, still ambiguous::

       """
       Usage: cmdname [options] arg1 arg2 ...

       We obviously *don't* want the like above to be interpreted as a
       field list item. Or do we?
       """

   Conclusion: was accepted (although not yet implemented; see below);
   currently reconsidering.

3. Use a directive::

       .. fields::

          Author: Me
          Version: 1

   Advantages: explicit and unambiguous, RFC822-compliant.
   Disadvantage: cumbersome.

4. Use Javadoc-style::

       @Author: Me
       @Version: 1
       @param a: integer

   Advantages: unambiguous, precedent, flexible. Disadvantages:
   non-intuitive, ugly, not RFC822-compliant.

5. Use leading colons::

       :Author: Me
       :Version: 1

   Advantages: unambiguous, obvious? (*almost* RFC822-compliant),
   flexible, perhaps even elegant. Disadvantage: no precedent, not
   quite RFC822-compliant.

One special context is defined for field lists [1]_. A field list as
the very first non-comment block, or the second non-comment block
immediately after a title, is interpreted as document bibliographic
data. No special syntax is required, just unadorned RFC822_ [2]_. The
first block ends with a blank line, therefore field bodies must be
single paragraphs only and there may be no blank lines between fields.
The following field names are recognized and transformed to the
corresponding DTD elements listed, child elements of the 'document'
element. No ordering is imposed on these fields:

- Title: title
- Subtitle: subtitle
- Author: author
- Authors: authors (a list of author elements)
- Organization: organization
- Contact: contact
- Version: version
- Status: status
- Date: date
- Copyright: copyright

This field-name-to-element mapping can be extended, or replaced for
other languages. See the implementation documentation for details.

.. _[1] Should "bibliographic field lists" be defined at the parser
   level, or at the DPS transformation level? In other words, are they
   reStructuredText-specific, or would they also be applicable to
   another (many/every other?) syntax?

.. _[2] Note that this "no special syntax required" provision is being
   reconsidered. An unambiguous syntax would also remove the
   requirement for a bibliographic field list to end with a blank
   line.


Literal Blocks
--------------

DTD element: literal_block.

Two colons ('::') at the end of a paragraph signifies that all
following **indented** text blocks comprise a literal block. No markup
processing is done within a literal block. It is left as-is, and is
typically rendered in a monospaced typeface::

    This is a typical paragraph. A literal block follows::

        for a in [5,4,3,2,1]:   # this is program code, shown as-is
            print a
        print "it's..."
        # a literal block continues until the indentation ends

    This text has returned to the indentation of the first paragraph,
    is outside of the literal block, and therefore treated as an
    ordinary paragraph.

When '::' is immediately preceded by whitespace, both colons will be
removed from the output. When text immediately precedes the '::',
*one* colon will be removed from the output, leaving only one (i.e.,
'::' will be replaced by ':'). When '::' is alone on a line, it will
be completely removed from the output; no empty paragraph will remain.

In other words, these are all equivalent:

1. Minimized::

      Paragraph::

          Literal block

2. Partly expanded::

      Paragraph: ::

          Literal block

3. Fully expanded::

      Paragraph:

      ::

          Literal block

The minimum leading whitespace will be removed from each line of the
literal block. Other than that, all whitespace (including line breaks)
is preserved. Blank lines are required before and after a literal
block, but these blank lines are not included as part of the literal
block.

Syntax diagram::

    +------------------------------+
    | paragraph                    |
    | (ends with '::')             |
    +------------------------------+
       +---------------------------+
       | literal block             |
       +---------------------------+


Block Quotes
------------

DTD element: block_quote.

A text block that is indented relative to the preceding text, without
markup indicating it to be a literal block, is a block quote. All
markup processing (for body elements and inline markup) continues
within the block quote::

    This is an ordinary paragraph, introducing a block quote:

        "It is my business to know things. That is my trade."

        --Sherlock Holmes

Blank lines are required before and after a block quote, but these
blank lines are not included as part of the block quote.

Syntax diagram::

    +------------------------------+
    | (current level of            |
    | indentation)                 |
    +------------------------------+
       +---------------------------+
       | block quote               |
       | (body elements)+          |
       +---------------------------+


Tables
------

DTD elements: table, tgroup, colspec, thead, tbody, row, entry.

Tables are described with a visual outline made up of the characters
'-', '=', '|', and '+'. The hyphen ('-') is used for horizontal lines
(row separators). The equals sign ('=') may be used to separate
optional header rows from the table body. The vertical bar ('|') is
used for vertical lines (column separators). The plus sign ('+') is
used for intersections of horizontal and vertical lines.

Each table cell is treated as a miniature document; the top and
bottom cell boundaries act as delimiting blank lines. Each cell
contains zero or more body elements. Example::

    +------------------------+------------+----------+----------+
    | Header row, column 1   | Header 2   | Header 3 | Header 4 |
    | (header rows optional) |            |          |          |
    +========================+============+==========+==========+
    | body row 1, column 1   | column 2   | column 3 | column 4 |
    +------------------------+------------+----------+----------+
    | body row 2             | Cells may span columns.          |
    +------------------------+------------+---------------------+
    | body row 3             | Cells may  | - Table cells       |
    +------------------------+ span rows. | - contain           |
    | body row 4             |            | - body elements.    |
    +------------------------+------------+---------------------+

As with other body elements, blank lines are required before and after
tables. Tables' left edges should align with the left edge of
preceding text blocks; otherwise, the table is considered to be part
of a block quote.


Explicit Markup Blocks
----------------------

An explicit markup block is a text block:

- whose first line begins with '.. ' (the 'explicit markup start'),
- whose second and subsequent lines (if any) are indented relative to
  the first, and
- which ends with an unindented line.

Explicit markup blocks are analogous to bullet list items, with '..'
as the bullet. Blank lines are required between explicit markup blocks
and other elements, but are optional between explicit markup blocks
where unambiguous.

The explicit markup syntax is used for footnotes, hyperlink targets,
directives, and comments.


Footnotes
`````````

DTD elements: footnote, label.

Footnotes consist of an explicit markup start ('.. '), an underscore,
a left square bracket, the footnote label, a right square bracket,
and whitespace, followed by body elements. Footnote labels are simple `hyperlink names`_ (case-insensitive single words consisting of alphanumerics plus hyphens,
underscores, and periods; no whitespace). If the first body element
within a footnote is a simple paragraph, it may begin on the same line
as the footnote label. Other elements must begin on a new line,
consistently indented and left-aligned.

Footnotes may occur anywhere in the document, not only at the end.
Where or how they appear in the processed output depends on the output
formatter. Here is a footnote, referred to in `Footnote References`_::

    .. _[GVR2001] Python Documentation; van Rossum, Drake, et al.;
       http://www.python.org/doc/

Syntax diagram::

    +-------+-------------------------+
    | '.. ' | '_[' label ']' footnote |
    +-------+                         |
            | (body elements)+        |
            +-------------------------+


Hyperlink Targets
`````````````````

DTD element: target.

Hyperlink targets consist of an explicit markup start ('.. '), an
underscore, the hyperlink name (no trailing underscore), a colon,
whitespace, and a link block. These are also called 'explicit
hyperlink targets', to differentiate them from `implicit hyperlink
targets`_ defined below.

Hyperlink names are whitespace-neutral and case-insensitive. See
`Hyperlink Names`_ below for details and examples.

To differentiate hyperlink targets from footnotes:

- square brackets are not used,
- hyperlink names may contain whitespace,
- a colon is required after the hyperlink name.

Hyperlink targets go together with `indirect hyperlinks`_ and
`internal hyperlinks`_. Internal hyperlink targets have empty link
blocks; they point to the next element. Indirect hyperlink targets
have an absolute or relative URI in their link blocks.

An indirect hyperlink's URI may begin on the same line as the explicit
markup start and target name, or it may begin in an indented text
block immediately following, with no intervening blank lines. If there
are multiple lines in the link block, they are stripped of leading and
trailing whitespace and joined together. The following indirect
hyperlink targets are equivalent::

    .. _one-liner: http://structuredtext.sourceforge.net

    .. _starts-on-this-line: http://
                             structuredtext.
                             sourceforge.net

    .. _entirely-below:
       http://structuredtext.
       sourceforge.net

If a hyperlink name contains a colon followed by whitespace, either:

- the phrase must be enclosed in backquotes::

      .. _`FAQTS: Computers: Programming: Languages: Python`:
         http://python.faqts.com/

- or the colon(s) must be backslash-escaped in the link target::

      .. _Chapter One\: 'Tadpole Days':

      It's not easy being green...

See `Implicit Hyperlink Targets`_ below for the resolution of
duplicate hyperlink names.

Syntax diagram::

    +-------+----------------------+
    | '.. ' | '_' name ':' link    |
    +-------+              block   |
            |                      |
            +----------------------+


Implicit Hyperlink Targets
``````````````````````````

Implicit hyperlink targets are generated by section titles, and may
also be generated by extension constructs. Implicit hyperlink targets
behave identically to explicit `hyperlink targets`_.

Problems of ambiguity due to conflicting duplicate implicit and
explicit hyperlink names are avoided because the reStructuredText
parser follows these rules:

1. Explicit hyperlink targets override any implicit targets having the
   same hyperlink name. The implicit hyperlink targets are removed,
   and level-0 system warnings are inserted.

2. If two or more sections have the same title (such as "Introduction"
   subsections of a rigidly-structured document), there will be
   duplicate implicit target hyperlink names. Solution: all duplicate
   hyperlink targets are removed, and level-0 system warnings
   inserted.

3. If there are duplicate explicit hyperlink target names, all
   duplicates are removed, and level-1 system warnings inserted.

System warnings are inserted where target links have been removed. See
'Error Handling' in `PEP 258`_.

The parser must return a set of *unique* hyperlink targets. The
calling software (such as the `Python Docstring Processing System`_)
can warn of unresolvable links, giving reasons for the warnings.


Directives
``````````

DTD element: directive.

Directives are indicated by an explicit markup start ('.. ') followed
by the directive type, two colons, and whitespace. Directive types are
case-insensitive single words (alphanumerics plus hyphens and
underscores; no whitespace). Two colons are used after the directive
type for these reasons:

- To avoid clashes with common comment text like::

      .. Danger: modify at your own risk!

- If an implementation of reStructuredText does not recognize a
  directive (i.e., the directive-handler is not installed), the entire
  directive block (including the directive itself) will be treated as
  a literal block, and a warning generated. Thus '::' is a natural
  choice.

Actions taken in response to directives and the interpretation of data
in the directive block or subsequent text block(s) are
directive-dependent. No directives have been defined by the core
reStructuredText specification. The following are only examples of
*possible uses* of directives.

Directives can be used as an extension mechanism for reStructuredText.
For example, here's how a graphic could be placed::

    .. graphic:: mylogo.png

A figure (a graphic with a caption) could be placed like this::

    .. figure:: larch.png

       The larch.

Directives can also be used as pragmas, to modify the behavior of the
parser, such as to experiment with alternate syntax.

Syntax diagram::

    +-------+----------------------+
    | '.. ' | type '::' directive  |
    +-------+           block      |
            |                      |
            +----------------------+


Comments
````````

DTD element: comment.

Arbitrary text may follow the explicit markup start and will be
processed as a comment element. No further processing is done on the
comment block text; a comment contains a single "text blob". Depending
on the output formatter, comments may be removed from the processed
output. The only restriction on comments is that they not use the same
syntax as directives, footnotes, or hyperlink targets.

Syntax diagram::

    +-------+----------------------+
    | '.. ' | comment block        |
    +-------+                      |
            |                      |
            +----------------------+


Inline Markup
=============

Inline markup is the markup of words or phrases within a text block.
Inline markup cannot be nested.

There are eight inline markup constructs. Four of the constructs
(emphasis_, `strong emphasis`_, `interpreted text`_, and `inline
literals`_) use identical start-strings and end-strings to indicate
the markup. The `footnote references`_, `indirect hyperlinks`_, and
`internal hyperlinks`_ use differenct start-strings and end-strings.
`Standalone hyperlinks`_ are recognized implicitly, and use no extra
markup.

The inline markup start-string and end-string recognition rules are as
follows:

1. Inline markup start-strings must start a text block or be
   immediately preceded by whitespace, single or double quotes, '(',
   '[', '{', or '<'.

2. Inline markup start-strings must be immediately followed by
   non-whitespace.

3. Inline markup end-strings must be immediately preceded by
   non-whitespace.

4. Inline markup end-strings must end a text block or be immediately
   followed by whitespace, single or double quotes, '.', ',', ':',
   ';', '!', '?', '-', ')', ']', '}', or '>'.

5. If an inline markup start-string is immediately preceded by a
   single or double quote, '(', '[', '{', or '<', it must not be
   immediately followed by the corresponding single or double quote,
   ')', ']', '}', or '>'.

6. An inline markup end-string must be separated by at least one
   character from the start-string.

7. An unescaped backslash preceding a start-string or end-string will
   disable markup recognition, except for the end-string of `inline
   literals`_. See `escaping mechanism`_ above for details.

For example, none of the following are recognized as containing inline
markup start-strings: ' * ', '"*"', "'*'", '(*)', '(* ', '[*]', '{*}',
'\*', ' ` ', etc.


Emphasis
--------

DTD element: emphasis.

Start-string = end-string = '*'.

Text enclosed by single asterisk characters is emphasized::

    This is *emphasized text*.

Emphasized text is typically displayed in italics.


Strong Emphasis
---------------

DTD element: strong.

Start-string = end-string = '**'.

Text enclosed by double-asterisks is emphasized strongly::

    This is **strong text**.

Strongly emphasized text is typically displayed in boldface.


Interpreted Text
----------------

DTD element: interpreted.

Start-string = end-string = '`'.

Text enclosed by single backquote characters is interpreted::

    This is `interpreted text`.

The semantics of interpreted text are domain-dependent. It can be used
as implicit or explicit descriptive markup (such as for program
identifiers, as in the `Python Extensions to reStructuredText`_), for
cross-reference interpretation (such as index entries), or for other
applications where context can be inferred.

The role of the interpreted text may be inferred implicitly. The role
of the interpreted text may also be indicated explicitly, using either
a prefix (role + colon + space) or a suffix (space + colon + role),
depending on which reads better::

    `role: interpreted text`

    `interpreted text :role`

A role name may contain arbitrary text, except colons. Interpreted
text may contain at most one colon in a role-indicating context.


Inline Literals
---------------

DTD element: literal.

Start-string = end-string = '``'.

Text enclosed by double-backquotes is treated as inline literals::

    This text is an example of ``inline literals``.

Inline literals may contain any characters except two adjacent
backquotes in an end-string context (according to the recognition
rules above). No markup interpretation (including backslash-escape
interpretation) is done within inline literals.

Line breaks are *not* preserved in inline literals. Although a
reStructuredText parser will preserve runs of spaces in its output,
the final representation of the processed document is dependent on the
output formatter, thus the preservation of whitespace cannot be
guaranteed. If the preservation of line breaks and/or other whitespace
is important, literal blocks should be used.

Inline literals are useful for short code snippets. For example::

    The regular expression ``[+-]?(\d+(\.\d*)?|\.\d+)`` matches
    floating-point numbers (without exponents).


Hyperlinks
----------

Hyperlinks are indicated by a trailing underscore, '_', except for
`standalone hyperlinks`_ which are recognized independently. The
underscore can be thought of as a right-pointing arrow. The trailing
underscores point away from hyperlink references, and the leading
underscores point toward `hyperlink targets`_.


Hyperlink Names
```````````````

Simple hyperlink names are single words consisting of alphanumerics
plus internal hypens, underscores, and periods; no whitespace or other
characters are allowed. Footnote labels must be simple hyperlink
names.

Hyperlink names using punctuation or whose names are phrases (two or
more space-separated words) are called 'phrase-links'. Phrase-links
are expressed by enclosing the phrase in backquotes and treating
the backquoted text as a link name::

    Want to learn about `my favorite programming language`_?

    .. _my favorite programming language: http://www.python.org

Simple hyperlink names may also optionally use backquotes.

Hyperlink names are whitespace-neutral and case-insensitive. When
resolving hyperlink names internally:

- whitespace is normalized (one or more spaces, horizontal or vertical
  tabs, newlines, carriage returns, or form feeds, are interpreted as
  a single space), and

- case is normalized (all alphabetic characters are converted to
  lowercase).

For example, the following hyperlinks are equivalent::

    - `A HYPERLINK`_
    - `a    hyperlink`_
    - `A
      Hyperlink`_


Indirect Hyperlinks
```````````````````

DTD element: link.

- Start-string = '' (empty string), end-string: '_'.
- Start-string = '`', end-string: = '`_'. (Phrase links.)

Indirect hyperlinks consist of two parts. In the text body, there is a
source link, a hyperlink name with a trailing underscore::

    See the Python_ home page for info.

A target link containing a URI must exist somewhere else in the
document (see `Hyperlink Targets`_ for a full description)::

    .. _Python: http://www.python.org

After processing into HTML, this would be expressed as::

    See the <A HREF="http://www.python.org">Python</A> home page for
    info.


Internal Hyperlinks
```````````````````

DTD element: link.

- Start-string = '' (empty string), end-string: '_'.
- Start-string = '`', end-string: = '`_'.

Internal hyperlinks connect one point to another within a document.
They are identical to `indirect hyperlinks`_ except that there is no
URI in the target link. See `Hyperlink Targets`_ for a full
description. For example::

    Clicking on this internal hyperlink will take us to the target_
    below.

    .. _target:

    The hyperlink target above points to this paragraph.


Footnote References
```````````````````

DTD element: footnote_reference.

Start-string = '[', end-string = ']_'.

Footnote references consist of a square-bracketed label followed by a
trailing underscore. Footnote labels are simple `hyperlink names`_
(case-insensitive single words, consisting of alphanumerics plus
internal hyphens, underscores, and periods; no whitespace). For
example::

    Please refer to the fine manual [GVR2001]_.

See Footnotes_ for the footnote itself.


Standalone Hyperlinks
`````````````````````

DTD element: link.

Start-string = end-string = '' (empty string).

An absolute URI [URI]_ within a text block is treated as a general
external hyperlink with the URI itself as the link's text. For
example::

    See http://www.python.org for info.

would be marked up in HTML as::

    See <A HREF="http://www.python.org">http://www.python.org</A> for
    info.

Two forms of URI are recognized:

- absolute URIs beginning with a scheme ('http:', 'ftp:', 'mailto:',
  'telnet:', etc.), and

- standalone email addresses ('user@host').

Standalone email addresses are treated as if they had a 'mailto:'
prefix.

.. _[URI] Uniform Resource Identifier. URIs are a general form of URLs
    (Uniform Resource Locators). For the syntax of URIs see RFC2396_.


----------------
 Error Handling
----------------

Markup errors are handled according to the specification in `PEP
258`_.


.. _reStructuredText: http://structuredtext.sourceforge.net
.. _Python Docstring Processing System:
    http://docstring.sourceforge.net
.. _Doc-SIG: http://www.python.org/sigs/doc-sig/
.. _gpdi.dtd: http://docstring.sourceforge.net/spec/gpdi.dtd
.. _RFC822: http://www.rfc-editor.org/rfc/rfc822.txt
.. _RFC2396: http://www.rfc-editor.org/rfc/rfc2396.txt
.. _Python Extensions to reStructuredText:
    http://structuredtext.sourceforge.net/spec/pyextensions.txt
.. _PEP 258: http://docstring.sourceforge.net/spec/pep-0258.txt


Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End:
