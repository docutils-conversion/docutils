=======================================
 reStructuredText Markup Specification
=======================================
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Revision: $Revision: 1.19 $
:Date: $Date: 2001/09/28 04:59:27 $

reStructuredText_ is plain text that uses simple and intuitive
constructs to indicate the structure of a document. These constructs
are equally easy to read in raw and processed forms. This document is
itself an example of reStructuredText (raw, if you are reading the
text file, or processed, if you are reading an HTML document, for
example). reStructuredText is a candidate markup syntax for the
`Python Docstring Processing System`_.

Simple, implicit markup is used to indicate special constructs, such
as section headings, bullet lists, and emphasis. The markup used is as
minimal and unobtrusive as possible. Less often-used constructs and
extensions to the basic reStructuredText syntax may have more
elaborate or explicit markup.

reStructuredText is applicable to documents of any length, from the
very small (such as inline program documentation fragments, e.g.
Python docstrings) to the quite large (this document).

The first section gives a quick overview of the syntax of the
reStructuredText markup by example. More details are given in the
`Syntax Details`_ section.

`Literal blocks`_ (in which no markup processing is done) are used for
examples throughout this document, to illustrate the plain text
markup.


-----------------------
 Quick Syntax Overview
-----------------------

A reStructuredText document is made up of body elements, and may be
structured into sections. `Section Structure`_ is indicated through
title style (underlines & optional overlines). Sections contain body
elements and/or subsections.

Here are examples of body elements:

- Paragraphs_ (and `inline markup`_)::

      Paragraphs contain text and may contain inline markup:
      *emphasis*, **strong emphasis**, `interpreted text`, ``inline
      literals``, standalone hyperlinks (http://www.python.org),
      indirect hyperlinks (Python_), internal cross-references
      (example_), footnote references ([1]_).

      Paragraphs are separated by blank lines and are left-aligned.

- Five types of lists:

  1. `Bullet lists`_::

         - This is a bullet list.

         - Bullets can be "-", "*", or "+".

  2. `Enumerated lists`_::

         1. This is an enumerated list.

         2. Enumerators may be arabic numbers, letters, or roman
            numerals.

  3. `Definition lists`_::

         what
             Definition lists associate a term with a definition.

         how
             The term is a one-line phrase, and the definition is one
             or more paragraphs or body elements, indented relative to
             the term.

  4. `Field lists`_::

         :what: Field lists map field names to field bodies, like
                database records.

         :how: The field marker is a colon, the field name, optional
               field arguments, and a colon.

               The field body may contain one or more body elements,
               indented relative to the field marker.

  5. `Option lists`_, for listing command-line options::

         -a            option "a"
         -b file       options can have arguments
         --long        options can be long also
         --input=file  long options can also have arguments
         /V            DOS/VMS-style arguments too

     There must be at least two spaces between the option and the
     description.

- `Literal blocks`_::

      Literal blocks are indented, and indicated with a double-colon
      ("::") at the end of the preceding paragraph (right here -->)::

          if literal_block:
              text = 'is left as-is'
              spaces_and_linebreaks = 'are preserved'
              markup_processing = None

- `Block quotes`_::

      Block quotes consist of indented body elements:

          This theory, that is mine, is mine.

          Anne Elk (Miss)

- `Doctest blocks`_::

      >>> print 'Python-specific usage examples; begun with ">>>"'
      Python-specific usage examples; begun with ">>>"
      >>> print '(cut and pasted from interactive Python sessions)'
      (cut and pasted from interactive Python sessions)

- Tables_::

      +------------------------+------------+----------+
      | Header row, column 1   | Header 2   | Header 3 |
      +========================+============+==========+
      | body row 1, column 1   | column 2   | column 3 |
      +------------------------+------------+----------+
      | body row 2             | Cells may span        |
      +------------------------+------------+----------+

- Footnotes_::

      .. [1] A footnote contains indented body elements.

         It is a form of hyperlink target.

- `Hyperlink targets`_::

      .. _Python: http://www.python.org

      .. _example:

      The "_example" target above points to this paragraph.

- Directives_::

      .. graphic:: mylogo.png

- Comments_::

      .. Comments begin with two dots and a space. Anything may
         follow, except for the syntax of footnotes, hyperlink
         targets, and directives, described above.


----------------
 Syntax Details
----------------

Below is a diagram of the hierarchy of element types in
reStructuredText. Elements may contain other elements below them.
Element types in parentheses indicate recursive or one-to-many
relationships: sections may contain (sub)sections, tables contain
further body elements, etc. ::

    +--------------------------------------------------------------------+
    | document                                                           |
    |                             +--------------------------------------+
    | [root element]              |                           +-------+  |
    |                             | sections  [begin with one | title |] |
    |                             |                           +-------+  |
    |-----------------------------+-------------------------+------------|
    | [body elements:]                                      | (sections) |
    |         | - literal | - lists  |       | - hyperlink  +------------+
    |         |   blocks  | - tables |       |   targets    |
    | para-   | - doctest | - block  | foot- | - directives |
    | graphs  |   blocks  |   quotes | notes | - comments   |
    +---------+-----------+----------+-------+--------------+
    | [text]+ | [text]    | (body elements)  | [text]       |
    | (inline +-----------+------------------+--------------+
    | markup) |
    +---------+

For definitive element hierarchy details, see the "Generic Plaintext
Document Interface DTD" XML document type definition, gpdi.dtd_.
Descriptions below list "DTD elements" (XML "generic identifiers")
corresponding to syntax constructs.


Document
========

DTD element: document.

The top-level element of a parsed reStructuredText document is the
"document" element. After initial parsing, the document element is a
simple container for a document fragment, consisting of sections and
body elements, but lacking a document title or other bibliographic
elements. The code that calls the parser may choose to run one or more
optional `post-parse transformations`_, rearranging the document
fragment into a complete document with a title and possibly other
metadata elements (author, date, etc.).


Whitespace
==========

Blank lines are used to separate paragraphs and other elements.
Multiple successive blank lines are equivalent to a single blank line,
except within literal blocks (where all whitespace is preserved).
Blank lines may be omitted when the markup makes element separation
unambiguous, in conjunction with indentation. The first line of a
document is treated as if it is preceded by a blank line, and the last
line of a document is treated as if it is followed by a blank line.

Indentation is used to indicate, and is only significant in
indicating:

- multiple body elements within a list item (including nested lists),
- the definition part of a definition list item,
- block quotes,
- the extent of literal blocks, and
- the extent of explicit markup blocks.

Any text whose indentation is less than that of the current level
(i.e., unindented text or "dedents") ends the current level of
indentation.

Spaces are recommended for indentation, but tabs may also be used.
Tabs will be converted to spaces. Tab stops are at every 8th column.

Other whitespace characters (form feeds [chr(12)] and vertical tabs
[chr(11)]) are converted to single spaces before processing.


Escaping Mechanism
==================

The character set available in plain text documents, 7-bit ASCII, is
limited. No matter what characters are used for markup, they will
already have multiple meanings in written text. Therefore markup
characters *will* sometimes appear in text **without being intended as
markup**.

Any serious markup system requires an escaping mechanism to override
the default meaning of the characters used for the markup. In
reStructuredText we use the backslash, commonly used as an escaping
character in other domains.

A backslash followed by any character escapes the character. The
escaped character represents the character itself, and is prevented
from playing a role in any markup interpretation. The backslash is
removed from the output. A literal backslash is represented by two
backslashes in a row.

There are two contexts in which backslashes have no special meaning:
literal blocks and inline literals. In these contexts, a single
backslash represents a literal backslash.

Please note that the reStructuredText specification and parser do not
address the issue of the representation or extraction of text input
(how and in what form the text actually *reaches* the parser).
Backslashes and other characters may serve a character-escaping
purpose in certain contexts and must be dealt with appropriately. For
example, Python uses backslashes in strings to escape certain
characters, but not others. The simplest solution when backslashes
appear in Python docstrings is to use raw docstrings::

    r"""This is a raw docstring. Backslashes (\) are not touched."""


Section Structure
=================

DTD elements: section, title.

Sections are identified through their titles, which are marked up with
adornment: "underlines" below the title text, and, in some cases,
matching "overlines" above the title. An underline/overline is a
single repeated punctuation character that begins in column 1 and
forms a line extending at least as far as the right edge of the title
text. Specifically, an underline/overline character may be any
non-alphanumeric printable 7-bit ASCII character [#]_. An
underline/overline must be at least 4 characters long (to avoid
mistaking ellipses ["..."] for overlines). When an overline is used,
the length and character used must match the underline. There may be
any number of levels of section titles.

.. [#] The following are all valid section header underline/overline
   characters::

       ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~

   Some characters are more suitable than others. The following are
   recommended::

       = - ` : ' " ~ ^ _ * + # < >

Rather than imposing a fixed number and order of section title
adornment styles, the order enforced will be the order as encountered.
The first style encountered will be an outermost title (like HTML H1),
the second style will be a subtitle, the third will be a subsubtitle,
and so on.

Below are examples of section title styles::

    ===============
     Section Title
    ===============

    ---------------
     Section Title
    ---------------

    Section Title
    =============

    Section Title
    -------------

    Section Title
    `````````````

    Section Title
    '''''''''''''

    Section Title
    .............

    Section Title
    ~~~~~~~~~~~~~

    Section Title
    *************

    Section Title
    +++++++++++++

    Section Title
    ^^^^^^^^^^^^^

When a title has both an underline and an overline, the title text may
be inset, as in the first two examples above. This is merely aesthetic
and not significant. Underline-only title text may not be inset.

A blank line after a title is optional. All text blocks up to the next
title of the same or higher level are included in a section (or
subsection, etc.).

All section title styles need not be used, nor need any specific
section title style be used. However, a document must be consistent in
its use of section titles: once a hierarchy of title styles is
established, sections must use that hierarchy.

Each section title automatically generates a hyperlink target pointing
to the section. The text of the hyperlink target is the same as that
of the section title. See `Implicit Hyperlink Targets`_ for a complete
description.


Body Elements
=============

Paragraphs
----------

DTD element: paragraph.

Paragraphs consist of blocks of left-aligned text with no markup
indicating any other body element. Blank lines separate paragraphs
from each other and from other body elements. Paragraphs may contain
`inline markup`_.

Syntax diagram::

    +------------------------------+
    | paragraph                    |
    |                              |
    +------------------------------+
    +------------------------------+
    | paragraph                    |
    |                              |
    +------------------------------+


Bullet Lists
------------

DTD elements: bullet_list, list_item.

A text block which begins with a "-", "*", or "+", followed by
whitespace, is a bullet list item (a.k.a. "unordered" list item). For
example::

    - This is the first bullet list item. The blank line above the
      first list item is required; blank lines between list items
      (such as below this paragraph) are optional. Text blocks must be
      left-aligned, indented relative to the bullet.

    - This is the first paragraph in the second item in the list.

      This is the second paragraph in the second item in the list. The
      blank line above this paragraph is required. The left edge of
      this paragraph lines up with the paragraph above, both indented
      relative to the bullet.

      - This is a sublist. The bullet lines up with the left edge of
        the text blocks above. A sublist is a new list so requires a
        blank line above and below.

    - This is the third item of the main list.

    This paragraph is not part of the list.

Here are examples of **incorrectly** formatted bullet lists::

    - This first line is fine.
    A blank line is required between list items and paragraphs.
    (Warning)

    - The following line appears to be a new sublist, but it is not:
      - This is a paragraph contination, not a sublist (since there's
        no blank line). This line is also incorrectly indented.
      - Warnings may be issued by the implementation.

Syntax diagram::

    +------+-----------------------+
    | "- " | list item             |
    +------| (body elements)+      |
           +-----------------------+


Enumerated Lists
----------------

DTD elements: enumerated_list, list_item.

Enumerated lists (a.k.a. "ordered" lists) are similar to bullet lists,
but use enumerators instead of bullets. An enumerator consists of an
enumeration sequence member and formatting, followed by whitespace.
The following enumeration sequences are recognized:

- arabic numerals: 1, 2, 3, ... (no upper limit).
- uppercase alphabet characters: A, B, C, ..., Z.
- lower-case alphabet characters: a, b, c, ..., z.
- uppercase Roman numerals: I, II, III, IV, ..., MMMMCMXCIX (4999).
- lowercase Roman numerals: i, ii, iii, iv, ..., mmmmcmxcix (4999).

The following formatting types are recognized:

- suffixed with a period: "1.", "A.", "a.", "I.", "i.".
- surrounded by parentheses: "(1)", "(A)", "(a)", "(I)", "(i)".
- suffixed with a right-parenthesis: "1)", "A)", "a)", "I)", "i)".

A system warning will be generated for each of the following cases:

1. The enumerators do not all have the same format and sequence type.

2. The enumerators are not in sequence (i.e., "1.", "3." generates a
   warning).

It is recommended that the enumerator of the first list item be
ordinal-1 ("1", "A", "a", "I", or "i"). Although other start-values
will be recognized, they may not be supported by the output format.

Lists using Roman numerals must begin with "I"/"i" or a
multi-character value, such as "II" or "XV". Any other
single-character Roman numeral ("V", "X", etc.) will be interpreted as
a letter of the alphabet, not as a Roman numeral. Likewise, lists
using letters of the alphabet may not begin with "I"/"i", since these
are recognized as Roman numeral 1.

Nested enumerated lists must be created with indentation. For
example::

    1. Item 1.

       a) Item 1a.
       b) Item 1b.

Example syntax diagram::

    +-------+----------------------+
    | "1. " | list item            |
    +-------| (body elements)+     |
            +----------------------+


Definition Lists
----------------

DTD elements: definition_list, definition_list_item, term, classifier,
definition.

Each definition list item contains a term, an optional classifier, and
a definition. A term is a simple one-line word or phrase. An optional
classifier may follow the term on the same line, after " : " (space,
colon, space). A definition is a block indented relative to the term,
and may contain multiple paragraphs and other body elements. There may
be no blank line between a term and a definition (this distinguishes
definition lists from `block quotes`_). Blank lines are required
before the first and after the last definition list item, but are
optional in-between. For example::

    term 1
        Definition 1.

    term 2
        Definition 2, paragraph 1.

        Definition 2, paragraph 2.

    term 3 : classifier
        Definition 3.

A definition list may be used in various ways, including:

- As a dictionary or glossary. The term is the word itself, a
  classifier may be used to indicate the usage of the term (noun,
  verb, etc.), and the definition follows.

- To describe program variables. The term is the variable name, a
  classifier may be used to indicate the type of the variable (string,
  integer, etc.), and the definition describes the variable's use in
  the program. This usage of definition lists supports the classifier
  syntax of Grouch_, a system for describing and enforcing a Python
  object schema.

Syntax diagram::

    +---------------------------+
    | term [ " : " classifier ] |
    +--+------------------------+--+
       | defninition               |
       | (body elements)+          |
       +---------------------------+


Field Lists
-----------

DTD elements: field_list, field, field_name, field_argument,
field_body.

Field lists are mappings from field names to field bodies, modeled on
RFC822_ headers. A field name is made up of one or more letters,
numbers, and punctuation, except colons (":") and whitespace. Field
names are case-insensitive. There may be additional data separated
from the field name, called field arguments. The field name and
optional field argument(s) together form the field marker. The field
marker is preceded by a single colon, and followed by a single colon
and whitespace; this is followed by the field body. The field body may
contain multiple body elements, indented relative to the field marker.
For example::

    :Date: 2001-08-16
    :Version: 1
    :Authors: - Me
              - Myself
              - I
    :Indentation: Since the field marker may be quite long, the second
       and subsequent lines of the field body do not have to line up
       with the first line, but must line up with each other.
    :Parameter i: integer

Applications of reStructuredText may recognize field names and
transform fields or field bodies in certain contexts. See
`Bibliographic Field Lists`_ below. Any untransformed fields remain in
a generic field list.

Syntax diagram (simplified)::

    +------------------------------+------------+
    | ":" name (" " argument)* ":" | field body |
    +-------+----------------------+            |
            | (body elements)+                  |
            +-----------------------------------+


Option Lists
------------

DTD elements: option_list, option_list_item, option, short_option,
long_option, vms_option, option_argument, description.

Option lists are two-column lists of command-line options and
descriptions. There are three types of options:

- Short POSIX options consist of one dash and an option letter.
- Long POSIX options consist of two dashes and an option word.
- DOS options consist of a slash and an option letter.
- VMS options consist of a slash and an option word.

(Please note that POSIX-style and VMS-style options may also be used
by DOS or Windows software. The names above have been chosen for
convenience only.)

Although long POSIX option words and VMS option words may be allowed
to be truncated by the operating system or the application,
reStructuredText option lists do not show or support this with any
special syntax. The complete option word should be given, supported by
notes about truncation if and when applicable.

Options may be followed by an argument placeholder, whose role and
syntax should be explained in the description text. A variety of
separators may be used before argument placeholders. The following
table details the valid combinations (empty cells are invalid):

+-------------+----------+-------------------------------------------+
|             | Option   | Separator (between option & argument)     |
|             | With No  +--------------+--------------+-------------+
| Option Type | Argument | Space (" ")  | Equals ("=") | Colon (":") |
+=============+==========+==============+==============+=============+
| Short POSIX | -o       | -o arg       |              |             |
+-------------+----------+--------------+--------------+-------------+
| Long POSIX  | --option | --option arg | --option=arg |             |
+-------------+----------+--------------+--------------+-------------+
| DOS         | /O       | /O arg       |              |             |
+-------------+----------+--------------+--------------+-------------+
| VMS         | /OPTION  | /OPTION arg  | /OPTION=arg  | /OPTION:arg |
+-------------+----------+--------------+--------------+-------------+

Multiple variant option types may be listed for each option, separated
by comma-space. There must be at least two spaces between the
option(s) and the description. The description may contain multiple
body elements. As with other types of lists, blank lines are required
before the first option list item and after the last, but are optional
between option entries. For example::

    -a         Output all.
    -b         Output both (this description is
               quite long).
    -c arg     Output just arg.
    --long     Output all day long.
    -2, --two  This option has two variants.
    /V         A DOS-style option.
    /DIRECTORY  A VMS-syle option. Note the adjustment for the required
                two spaces.

    -p         This option has two paragraphs in the description.
               This is the first.

               This is the second.

Syntax diagram (simplified)::

    +--------------------------------+-------------+
    | "-" letter [" " argument] "  " | description |
    +-------+------------------------+             |
            | (body elements)+                     |
            +--------------------------------------+


Literal Blocks
--------------

DTD element: literal_block.

A paragraph consisting of two colons ("::") signifies that all
following **indented** text blocks comprise a literal block. No markup
processing is done within a literal block. It is left as-is, and is
typically rendered in a monospaced typeface::

    This is a typical paragraph. A literal block follows.

    ::

        for a in [5,4,3,2,1]:   # this is program code, shown as-is
            print a
        print "it's..."
        # a literal block continues until the indentation ends

    This text has returned to the indentation of the first paragraph,
    is outside of the literal block, and therefore treated as an
    ordinary paragraph.

The paragraph containing only "::" will be completely removed from the
output; no empty paragraph will remain.

As a convenience, the "::" is recognized at the end of any paragraph.
If immediately preceded by whitespace, both colons will be removed
from the output (this is the "partially minimized" form). When text
immediately precedes the "::", *one* colon will be removed from the
output, leaving only one (i.e., "::" will be replaced by ":"; the
"fully minimized" form).

In other words, these are all equivalent (please pay attention to the
colons after "Paragraph"):

1. Expanded form::

      Paragraph:

      ::

          Literal block

2. Partially minimized form::

      Paragraph: ::

          Literal block

3. Fully minimized form::

      Paragraph::

          Literal block

The minimum leading whitespace will be removed from each line of the
literal block. Other than that, all whitespace (including line breaks)
is preserved. Blank lines are required before and after a literal
block, but these blank lines are not included as part of the literal
block.

Syntax diagram::

    +------------------------------+
    | paragraph                    |
    | (ends with "::")             |
    +------------------------------+
       +---------------------------+
       | literal block             |
       +---------------------------+


Block Quotes
------------

DTD element: block_quote.

A text block that is indented relative to the preceding text, without
markup indicating it to be a literal block, is a block quote. All
markup processing (for body elements and inline markup) continues
within the block quote::

    This is an ordinary paragraph, introducing a block quote:

        "It is my business to know things. That is my trade."

        --Sherlock Holmes

Blank lines are required before and after a block quote, but these
blank lines are not included as part of the block quote.

Syntax diagram::

    +------------------------------+
    | (current level of            |
    | indentation)                 |
    +------------------------------+
       +---------------------------+
       | block quote               |
       | (body elements)+          |
       +---------------------------+


Doctest Blocks
--------------

DTD element: doctest_block.

Doctest blocks are interactive Python sessions cut-and-pasted into
docstrings. They are meant to illustrate usage by example, and provide
an elegant and powerful testing environment via the doctest module in
the Python standard library.

Doctest blocks are text blocks which begin with ">>> ", the Python
interactive interpreter main prompt, and end with a blank line.
Doctest blocks are treated as a special case of literal blocks,
without requiring the literal block syntax. If both are present, the
literal block syntax takes priority over Doctest block syntax::

    This is an ordinary paragraph.

    >>> print 'this is a Doctest block'
    this is a Doctest block

    The following is a literal block::

        >>> This is not recognized as a doctest block by
        reStructuredText. It *will* be recognized by the doctest
        module, though!

Indentation is not required for doctest blocks.


Tables
------

DTD elements: table, tgroup, colspec, thead, tbody, row, entry.

Tables are described with a visual outline made up of the characters
"-", "=", "|", and "+". The hyphen ("-") is used for horizontal lines
(row separators). The equals sign ("=") may be used to separate
optional header rows from the table body. The vertical bar ("|") is
used for vertical lines (column separators). The plus sign ("+") is
used for intersections of horizontal and vertical lines.

Each table cell is treated as a miniature document; the top and
bottom cell boundaries act as delimiting blank lines. Each cell
contains zero or more body elements. Example::

    +------------------------+------------+----------+----------+
    | Header row, column 1   | Header 2   | Header 3 | Header 4 |
    | (header rows optional) |            |          |          |
    +========================+============+==========+==========+
    | body row 1, column 1   | column 2   | column 3 | column 4 |
    +------------------------+------------+----------+----------+
    | body row 2             | Cells may span columns.          |
    +------------------------+------------+---------------------+
    | body row 3             | Cells may  | - Table cells       |
    +------------------------+ span rows. | - contain           |
    | body row 4             |            | - body elements.    |
    +------------------------+------------+---------------------+

As with other body elements, blank lines are required before and after
tables. Tables' left edges should align with the left edge of
preceding text blocks; otherwise, the table is considered to be part
of a block quote.


Explicit Markup Blocks
----------------------

An explicit markup block is a text block:

- whose first line begins with ".." followed by whitespace (the
  "explicit markup start"),
- whose second and subsequent lines (if any) are indented relative to
  the first, and
- which ends with an unindented line.

Explicit markup blocks are analogous to bullet list items, with ".."
as the bullet. Blank lines are required between explicit markup blocks
and other elements, but are optional between explicit markup blocks
where unambiguous.

The explicit markup syntax is used for footnotes, hyperlink targets,
directives, and comments.


Footnotes
`````````

DTD elements: footnote, label.

Footnotes consist of an explicit markup start (".. "), a left square
bracket, the footnote label, a right square bracket, and whitespace,
followed by body elements. Footnote labels can be:

- simple `hyperlink names`_ (case-insensitive single words consisting
  of alphanumerics plus internal hyphens, underscores, and periods; no
  whitespace),

- a single "#" (denoting `auto-numbered footnotes`_), or

- a "#" followed by a simple hyperlink name, an "autonumber label".

If the first body element within a footnote is a simple paragraph, it
may begin on the same line as the footnote label. Other elements must
begin on a new line, consistently indented and left-aligned.

Footnotes may occur anywhere in the document, not only at the end.
Where or how they appear in the processed output depends on the output
formatter. Here is a footnote, referred to in `Footnote References`_::

    .. [GVR2001] Python Documentation; van Rossum, Drake, et al.;
       http://www.python.org/doc/

Each footnote automatically generates a hyperlink target pointing to
itself. The text of the hyperlink target name is the same as that of
the footnote label. `Auto-numbered footnotes`_ generate a number as
their footnote label and hyperlink name. See `Implicit Hyperlink
Targets`_ for a complete description of the mechanism.

Syntax diagram::

    +-------+-------------------------+
    | ".. " | "[" label "]" footnote  |
    +-------+                         |
            | (body elements)+        |
            +-------------------------+


Auto-Numbered Footnotes
.......................

A number sign ("#") may be used as the first character of a footnote
label to request automatic numbering of the footnote or footnote
reference.

The first footnote to request automatic numbering is assigned the
label "1", the second is assigned the label "2", and so on. Automatic
footnote numbering may not be mixed with manual footnote numbering; it
would cause numbering and referencing conflicts. Footnotes using
non-numeric labels, such as ``[note]`` or ``[GVR2001]`` may be used
together with automatic numbering. A footnote which has automatically
received a label "1" generates an implicit hyperlink target with name
"1", just as if the label was explicitly specified.

A footnote may specify a label explicitly while at the same time
requesting automatic numbering: ``[#label]``. These labels are called
"autonumber labels". Autonumber labels do two things:

- On the footnote itself, they generate a hyperlink target whose name
  is the autonumber label (doesn't include the "#").

- They allow an automatically numbered footnote to be referred to more
  than once, as a footnote reference or hyperlink. For example::

    If [#note]_ is the first footnote reference, it will show up as
    "[1]". We can refer to it again as [#note]_ and again see "[1]".
    We can also refer to it as note_ (an ordinary internal hyperlink).

    .. [#note] This is the footnote "note".

The numbering is determined by the order of the footnotes, not by the
order of the references. For footnote references without autonumber
labels (``[#]_``), the footnotes and footnote references must be in
the same relative order but need not alternate in lock-step. For
example::

    [#]_ is a reference to footnote 1, and [#]_ is a reference to
    footnote 2.

    .. [#] This is footnote 1.
    .. [#] This is footnote 2.
    .. [#] This is footnote 3.

    [#]_ is a reference to footnote 3.


Hyperlink Targets
`````````````````

DTD element: target.

Hyperlink targets consist of an explicit markup start (".. "), an
underscore, the hyperlink name (no trailing underscore), a colon,
whitespace, and a link block. These are also called "explicit
hyperlink targets", to differentiate them from `implicit hyperlink
targets`_ defined below.

Hyperlink names are whitespace-neutral and case-insensitive. See
`Hyperlink Names`_ below for details and examples.

To differentiate hyperlink targets from footnotes:

- square brackets are not used,
- hyperlink names may contain whitespace,
- a colon is required after the hyperlink name.

Hyperlink targets go together with `indirect hyperlinks`_ and
`internal hyperlinks`_. Internal hyperlink targets have empty link
blocks; they point to the next element. Indirect hyperlink targets
have an absolute or relative URI in their link blocks.

An indirect hyperlink's URI may begin on the same line as the explicit
markup start and target name, or it may begin in an indented text
block immediately following, with no intervening blank lines. If there
are multiple lines in the link block, they are stripped of leading and
trailing whitespace and joined together. The following indirect
hyperlink targets are equivalent::

    .. _one-liner: http://structuredtext.sourceforge.net

    .. _starts-on-this-line: http://
                             structuredtext.
                             sourceforge.net

    .. _entirely-below:
       http://structuredtext.
       sourceforge.net

If a hyperlink name contains a colon followed by whitespace, either:

- the phrase must be enclosed in backquotes::

      .. _`FAQTS: Computers: Programming: Languages: Python`:
         http://python.faqts.com/

- or the colon(s) must be backslash-escaped in the link target::

      .. _Chapter One\: "Tadpole Days":

      It's not easy being green...

See `Implicit Hyperlink Targets`_ below for the resolution of
duplicate hyperlink names.

Syntax diagram::

    +-------+----------------------+
    | ".. " | "_" name ":" link    |
    +-------+              block   |
            |                      |
            +----------------------+


Implicit Hyperlink Targets
``````````````````````````

Implicit hyperlink targets are generated by section titles and
footnotes, and may also be generated by extension constructs. Implicit
hyperlink targets behave identically to explicit `hyperlink targets`_.

Problems of ambiguity due to conflicting duplicate implicit and
explicit hyperlink names are avoided because the reStructuredText
parser follows these rules:

1. Explicit hyperlink targets override any implicit targets having the
   same hyperlink name. The implicit hyperlink targets are removed,
   and level-0 system warnings are inserted.

2. If two or more sections have the same title (such as "Introduction"
   subsections of a rigidly-structured document), there will be
   duplicate implicit target hyperlink names. Solution: all duplicate
   hyperlink targets are removed, and level-0 system warnings
   inserted.

3. If there are duplicate explicit hyperlink target names which do not
   refer to identical URIs, all duplicates are removed, and level-1
   system warnings inserted.

System warnings are inserted where target links have been removed. See
"Error Handling" in `PEP 258`_.

The parser must return a set of *unique* hyperlink targets. The
calling software (such as the `Python Docstring Processing System`_)
can warn of unresolvable links, giving reasons for the warnings.


Directives
``````````

DTD element: directive.

Directives are indicated by an explicit markup start (".. ") followed
by the directive type, two colons, and whitespace. Directive types are
case-insensitive single words (alphanumerics plus internal hyphens,
underscores, and periods; no whitespace). Two colons are used after
the directive type for these reasons:

- To avoid clashes with common comment text like::

      .. Danger: modify at your own risk!

- If an implementation of reStructuredText does not recognize a
  directive (i.e., the directive-handler is not installed), the entire
  directive block (including the directive itself) will be treated as
  a literal block, and a warning generated. Thus "::" is a natural
  choice.

Any text on the first line after the directive indicator is directive
data. The interpretation of directive data is up to the directive
code.  Directive data may be interpreted as arguments to the
directive, or simply as the first line of the directive's text block.

Actions taken in response to directives and the interpretation of text
in the directive block or subsequent text block(s) are
directive-dependent. Indented text following a directive may be
interpreted as a directive block. Simple directives may not require
any text beyond the directive data (if that), and will not process any
following indented text.

No directives are defined in the core reStructuredText
specification. Directives which have been implemented and registered
in the reference reStructuredText parser are described in the
`reStructuredText Directives`_ document. Below are examples of
implemented directives.

Directives can be used as an extension mechanism for reStructuredText,
a way of adding support for new constructs without adding new syntax.
For example, here's how an image could be placed::

    .. image:: mylogo.png

A figure (a graphic with a caption) could be placed like this::

    .. figure:: larch.png
       The larch.

An admonition (note, caution, etc.) contains other body elements::

    .. note:: This is a paragraph

       - Here is a bullet list.

It may also be possible for directives to be used as pragmas, to
modify the behavior of the parser, such as to experiment with
alternate syntax. There is no parser support for this functionality at
present; if a reasonable need for pragma directives is found, they may
be supported.

Directives normally do not survive as "directive" elements past the
parsing stage; they are a *parser construct* only, and have no
intrinsic meaning outside of reStructuredText. Instead, the parser
will transform recognized directives into (possibly specialized)
document elements. Unknown directives will trigger level-2 (error)
system warnings.

Syntax diagram::

    +-------+----------------------+
    | ".. " | type "::" directive  |
    +-------+           block      |
            |                      |
            +----------------------+


Comments
````````

DTD element: comment.

Arbitrary indented text may follow the explicit markup start and will be
processed as a comment element. No further processing is done on the
comment block text; a comment contains a single "text blob". Depending
on the output formatter, comments may be removed from the processed
output. The only restriction on comments is that they not use the same
syntax as directives, footnotes, or hyperlink targets.

A comment start followed by a blank line and nothing else (apart from
whitespace) is an "empty comment". It serves to terminate a preceding
construct, and does **not** consume any indented text following. To
have a block quote follow a list or any indented construct, insert an
unindented empty comment in-between.

Syntax diagram::

    +-------+----------------------+
    | ".. " | comment block        |
    +-------+                      |
            |                      |
            +----------------------+


Inline Markup
=============

Inline markup is the markup of words or phrases within a text block.
Inline markup cannot be nested.

There are eight inline markup constructs. Four of the constructs
(emphasis_, `strong emphasis`_, `interpreted text`_, and `inline
literals`_) use identical start-strings and end-strings to indicate
the markup. The `footnote references`_, `indirect hyperlinks`_, and
`internal hyperlinks`_ use different start-strings and end-strings.
`Standalone hyperlinks`_ are recognized implicitly, and use no extra
markup.

The inline markup start-string and end-string recognition rules are as
follows:

1. Inline markup start-strings must start a text block or be
   immediately preceded by whitespace, single or double quotes, "(",
   "[", "{", or "<".

2. Inline markup start-strings must be immediately followed by
   non-whitespace.

3. Inline markup end-strings must be immediately preceded by
   non-whitespace.

4. Inline markup end-strings must end a text block or be immediately
   followed by whitespace, single or double quotes, ".", ",", ":",
   ";", "!", "?", "-", ")", "]", "}", or ">".

5. If an inline markup start-string is immediately preceded by a
   single or double quote, "(", "[", "{", or "<", it must not be
   immediately followed by the corresponding single or double quote,
   ")", "]", "}", or ">".

6. An inline markup end-string must be separated by at least one
   character from the start-string.

7. An unescaped backslash preceding a start-string or end-string will
   disable markup recognition, except for the end-string of `inline
   literals`_. See `escaping mechanism`_ above for details.

For example, none of the following are recognized as containing inline
markup start-strings: " * ", '"*"', "'*'", "(*)", "(* ", "[*]", "{*}",
"\*", " ` ", etc.

The inline markup recognition rules were devised intentionally to
allow 90% of legitimate uses of "*" and "`" *without* resorting to
backslashes. For 9 of the remaining 10%, use inline literals or
literal blocks::

    "``\*``" -> "\*" (possibly in another font or quoted)

Only those who understand the escaping and inline markup rules may
attempt the remaining 1%. ;-)


Emphasis
--------

DTD element: emphasis.

Start-string = end-string = "*".

Text enclosed by single asterisk characters is emphasized::

    This is *emphasized text*.

Emphasized text is typically displayed in italics.


Strong Emphasis
---------------

DTD element: strong.

Start-string = end-string = "**".

Text enclosed by double-asterisks is emphasized strongly::

    This is **strong text**.

Strongly emphasized text is typically displayed in boldface.


Interpreted Text
----------------

DTD element: interpreted.

Start-string = end-string = "`".

Text enclosed by single backquote characters is interpreted::

    This is `interpreted text`.

The semantics of interpreted text are domain-dependent. It can be used
as implicit or explicit descriptive markup (such as for program
identifiers, as in the `DPS Python Mode`_), for cross-reference
interpretation (such as index entries), or for other applications
where context can be inferred.

The role of the interpreted text is normally inferred implicitly. The
role of the interpreted text may also be indicated explicitly, using a
role marker, either as a prefix or as a suffix to the interpreted
text, depending on which reads better::

    :role:`interpreted text`

    `interpreted text`:role:

A role marker consists of a colon, the role name, and another colon. A
role name is a single word consisting of alphanumerics plus internal
hypens, underscores, and periods; no whitespace or other characters
are allowed.


Inline Literals
---------------

DTD element: literal.

Start-string = end-string = "``".

Text enclosed by double-backquotes is treated as inline literals::

    This text is an example of ``inline literals``.

Inline literals may contain any characters except two adjacent
backquotes in an end-string context (according to the recognition
rules above). No markup interpretation (including backslash-escape
interpretation) is done within inline literals.

Line breaks are *not* preserved in inline literals. Although a
reStructuredText parser will preserve runs of spaces in its output,
the final representation of the processed document is dependent on the
output formatter, thus the preservation of whitespace cannot be
guaranteed. If the preservation of line breaks and/or other whitespace
is important, literal blocks should be used.

Inline literals are useful for short code snippets. For example::

    The regular expression ``[+-]?(\d+(\.\d*)?|\.\d+)`` matches
    floating-point numbers (without exponents).


Hyperlinks
----------

Hyperlinks are indicated by a trailing underscore, "_", except for
`standalone hyperlinks`_ which are recognized independently. The
underscore can be thought of as a right-pointing arrow. The trailing
underscores point away from hyperlink references, and the leading
underscores point toward `hyperlink targets`_.


Hyperlink Names
```````````````

Simple hyperlink names are single words consisting of alphanumerics
plus internal hypens, underscores, and periods; no whitespace or other
characters are allowed. Footnote labels and `interpreted text`_ roles
have the same syntax as simple hyperlink names.

Hyperlink names using punctuation or whose names are phrases (two or
more space-separated words) are called "phrase-links". Phrase-links
are expressed by enclosing the phrase in backquotes and treating
the backquoted text as a link name::

    Want to learn about `my favorite programming language`_?

    .. _my favorite programming language: http://www.python.org

Simple hyperlink names may also optionally use backquotes.

Hyperlink names are whitespace-neutral and case-insensitive. When
resolving hyperlink names internally:

- whitespace is normalized (one or more spaces, horizontal or vertical
  tabs, newlines, carriage returns, or form feeds, are interpreted as
  a single space), and

- case is normalized (all alphabetic characters are converted to
  lowercase).

For example, the following hyperlinks are equivalent::

    - `A HYPERLINK`_
    - `a    hyperlink`_
    - `A
      Hyperlink`_


Indirect Hyperlinks
```````````````````

DTD element: link.

- Start-string = "" (empty string), end-string: "_".
- Start-string = "`", end-string: = "\`_". (Phrase links.)

Indirect hyperlinks consist of two parts. In the text body, there is a
source link, a hyperlink name with a trailing underscore::

    See the Python_ home page for info.

A target link containing a URI must exist somewhere else in the
document (see `Hyperlink Targets`_ for a full description)::

    .. _Python: http://www.python.org

After processing into HTML, this might be expressed as::

    See the <A HREF="http://www.python.org">Python</A> home page for
    info.


Internal Hyperlinks
```````````````````

DTD element: link.

- Start-string = "" (empty string), end-string: "_".
- Start-string = "`", end-string: = "\`_".

Internal hyperlinks connect one point to another within a document.
They are identical to `indirect hyperlinks`_ except that there is no
URI in the target link. See `Hyperlink Targets`_ for a full
description. For example::

    Clicking on this internal hyperlink will take us to the target_
    below.

    .. _target:

    The hyperlink target above points to this paragraph.


Footnote References
```````````````````

DTD element: footnote_reference.

Start-string = "[", end-string = "]_".

Footnote references consist of a square-bracketed label followed by a
trailing underscore. Footnote labels are one of:

- simple `hyperlink names`_ (case-insensitive single words, consisting
  of alphanumerics plus internal hyphens, underscores, and periods; no
  whitespace),

- a single "#" (denoting `auto-numbered footnotes`_), or

- a "#" followed by a simple hyperlink name, an "autonumber label".

For example::

    Please refer to the fine manual [GVR2001]_.

See Footnotes_ for the footnote itself.


Standalone Hyperlinks
`````````````````````

DTD element: link.

Start-string = end-string = "" (empty string).

A URI (absolute URI [#URI]_ or standalone email address) within a text
block is treated as a general external hyperlink with the URI itself
as the link's text. For example::

    See http://www.python.org for info.

would be marked up in HTML as::

    See <A HREF="http://www.python.org">http://www.python.org</A> for
    info.

Two forms of URI are recognized:

1. Absolute URIs. These consist of a scheme, a colon (":"), and a
   scheme-specific part whose interpretation depends on the scheme.

   - The scheme is the name of the protocol, such as "http", "ftp",
     "mailto", or "telnet". The scheme consists of an initial letter,
     followed by letters, numbers, and/or "+", "-", ".".

   - The scheme-specific part of the resource identifier may be either
     hierarchical or opaque.

     - Hierarchical identifiers begin with one or two slashes and may
       use slashes to separate hierarchical components of the path.
       Examples are web pages and FTP sites:

           http://www.python.org

           ftp://ftp.python.org/pub/python

     - Opaque identifiers do not begin with slashes. Examples are
       email addresses and newsgroups::

           mailto:someone@somewhere.com

           news:comp.lang.python

   With queries, fragments, and %-escape sequences, URIs can become
   quite complicated. A reStructuredText parser must be able to
   recognize any absolute URI, as defined in RFC239_.

2. Standalone email addresses, which are treated as if they were
   ablsolute URIs with a "mailto:" scheme. Example::

       someone@somewhere.com

Punctuation at the end of a URI is not considered part of the URI.

.. [#URI] Uniform Resource Identifier. URIs are a general form of URLs
   (Uniform Resource Locators). For the syntax of URIs see RFC2396_.


----------------
 Error Handling
----------------

Markup errors are handled according to the specification in `PEP
258`_.


----------------------------
 Post-Parse Transformations
----------------------------

Each of the following transformations ties up certain "loose ends"
that remain after the initial parsing of input reStructuredText. Each
is an optional step that the DPS Reader may or may not choose to
perform on the parsed document, depending on the input context. The
DPS Reader may also perform context-specific transformations before
performing these standard transformations.


Section Promotion: Document Title & Subtitle
============================================

In reStructuredText, there is no way to specify a document title and
subtitle explicitly. Instead, we can supply the document title (and
possibly the subtitle as well) implicitly, and use this two-step
transformation to "raise" or "promote" the title(s) (and their
corresponding section contents) to the document level.

1. If the document contains a single top-level section as its first
   non-comment element, the top-level section's title becomes the
   document's title, and the top-level section's contents become the
   document's immediate contents. The lone top-level section header
   must be the first non-comment element in the document.

   For example, take this input text::

       =================
        Top-Level Title
       =================

       A paragraph.

   Once parsed, it looks like this::

       <document>
           <section name="top-level title">
               <title>
                   Top-Level Title
               <paragraph>
                   A paragraph.

   After running the Section Promotion transformation, we have::

       <document name="top-level title">
           <title>
               Top-Level Title
           <paragraph>
               A paragraph.

2. If step 1 successfully determines the document title, we continue
   by checking for a subtitle.

   If the lone top-level section itself contains a single second-level
   section as its first non-comment element, that section's title is
   promoted to the document's subtitle, and that section's contents
   become the document's immediate contents. Given this input text::

       =================
        Top-Level Title
       =================

       Second-Level Title
       ~~~~~~~~~~~~~~~~~~

       A paragraph.

   After parsing and running the Section Promotion transformation, the
   result is::

       <document name="top-level title">
           <title>
               Top-Level Title
           <subtitle name="second-level title">
               Second-Level Title
           <paragraph>
               A paragraph.

   (Note that the implicit hyperlink target generated by the
   "Second-Level Title" is preserved on the "subtitle" element itself.)

Any comment elements occurring before the document title or subtitle
are accumulated and inserted as the first body elements after the
title(s)


Bibliographic Field Lists
=========================

DTD elements: docinfo, author, authors, organization, contact,
version, status, date, copyright, abstract.

It is recommended that this transformation be run *after* the `Section
Promotion: Document Title & Subtitle`_ transformation.

When a field list is the first non-comment element in a document
(after the document title, if there is one), it may have certain
specific fields transformed to document bibliographic data. This
bibliographic data corresponds to the front matter of a book, such as
the title page and copyright page.

Registered field names are recognized and transformed to the
corresponding DTD elements, becoming child elements of the "docinfo"
element. No ordering is required of these fields, although they may be
rearranged to fit the document structure. Unless otherwise indicated
in the list below, each of the bibliographic elements' field bodies
may contain a single paragraph only.

The registered bibliographic field names and their corresponding DTD
elements are as follows:

- Field name "Author": author element.
- "Authors": authors. May contain either: a single paragraph
  consisting of a list of authors, separated by ";" or ","; or a
  bullet list whose elements each contain a single paragraph per
  author.
- "Organization": organization.
- "Contact": contact.
- "Version": version.
- "Status": status.
- "Date": date.
- "Copyright": copyright.
- "Abstract": abstract. May contain arbitrary body elements. The
  abstract always becomes the last child of the docinfo element. Only
  one abstract is allowed.

This field-name-to-element mapping can be extended, or replaced for
other languages. See the implementation documentation for details.


RCS Keywords
------------

Normally [#]_, recognized bibliographic fields are checked for RCS
[#]_ keywords and cleaned up. RCS keywords may be entered into source
files as "$keyword$", and once stored under RCS or CVS [#]_, they are
expanded to "$keyword: expansion text $". For example::

    :status: $keyword: expansion text $

Processed, the "status" element's text will simply be "expansion
text". The dollar signs and leading RCS keyword name are removed.

.. [#] RCS keyword processing can be turned off.
.. [#] Revision Control System.
.. [#] Concurrent Versions System. CVS uses the same keywords as RCS.

The RCS Keywords transformation is run on registered bibliographic
fields only. The sole contents of the field body must be an expanded
RCS keyword, of the form "$keyword: expansion text $". Any RCS keyword
can be processed in any bibliographic field. Extra processing is done
for the following RCS keywords:

- "RCSfile" expands to the name of the file in the RCS or CVS
  repository, which is the name of the source file with a ",v" suffix
  appended. The RCS Keywords transformation will remove the ",v"
  suffix. For example::

      :Status: $RCSfile: reStructuredText.txt,v $

  The "status" element's text will be "reStructuredText.txt".

- "Date" expands to the format "YYYY/MM/DD hh:mm:ss" (in the UTC time
  zone). The RCS Keywords transformation will extract just the date
  itself and transform it to an ISO 8601 format date, as in
  "2000-12-31".

  (Since the source file for this text is itself stored under CVS, we
  can't show an example of the "Date" RCS keyword because we can't
  prevent any RCS keywords used in this explanation from being
  expanded. Only the "RCSfile" keyword is stable; its expansion text
  changes only if the file name changes.)


Footnote Numbering
==================

XXX


Cross-Reference Resolution
==========================

XXX


Indirect Hyperlink Resolution
=============================

XXX


.. _reStructuredText: http://structuredtext.sourceforge.net
.. _Python Docstring Processing System:
    http://docstring.sourceforge.net
.. _Doc-SIG: http://www.python.org/sigs/doc-sig/
.. _gpdi.dtd: http://docstring.sourceforge.net/spec/gpdi.dtd
.. _Grouch: http://www.mems-exchange.org/software/grouch/
.. _RFC822: http://www.rfc-editor.org/rfc/rfc822.txt
.. _RFC2396: http://www.rfc-editor.org/rfc/rfc2396.txt
.. _reStructuredText Directives:
    http://structuredtext.sourceforge.net/spec/directives.txt
.. _Python Source Reader:
    http://docstring.sourceforge.net/spec/python-source.txt
.. _PEP 258: http://docstring.sourceforge.net/spec/pep-0258.txt


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
