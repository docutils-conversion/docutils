================================================
 Record of reStructuredText Syntax Alternatives
================================================
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Revision: $Revision: 1.9 $
:Date: $Date: 2001/11/06 00:49:35 $

The following are ideas, alternatives, and justifications that were
considered for reStructuredText syntax, which did not originate with
Setext_ or StructuredText_. For an analysis of constructs which *did*
originate with StructuredText or Setext, please see `Problems With
StructuredText`_. See the `reStructuredText Markup Specification`_ for
full details of the established syntax.

.. _Setext: http://www.bsdi.com/setext
.. _StructuredText:
   http://dev.zope.org/Members/jim/StructuredTextWiki/FrontPage
.. _Problems with StructuredText:
    http://structuredtext.sourceforge.net/spec/problems.txt
.. _reStructuredText Markup Specification:
   http://structuredtext.sourceforge.net/spec/reStructuredText.txt


Field Lists
===========

Prior to the syntax for field lists being finalized, several
alternatives were proposed.

1. Unadorned RFC822_ everywhere::

       Author: Me
       Version: 1

   Advantages: clean, precedent (RFC822-compliant). Disadvantage:
   ambiguous (these paragraphs are a prime example).

   Conclusion: rejected.

2. Special case: use unadorned RFC822_ for the very first or very last
   text block of a document::

       """
       Author: Me
       Version: 1

       The rest of the document...
       """

   Advantages: clean, precedent (RFC822-compliant). Disadvantages:
   special case, flat (unnested) field lists only, still ambiguous::

       """
       Usage: cmdname [options] arg1 arg2 ...

       We obviously *don't* want the like above to be interpreted as a
       field list item. Or do we?
       """

   Conclusion: rejected for the general case, accepted for specific
   contexts (PEPs, email).

3. Use a directive::

       .. fields::

          Author: Me
          Version: 1

   Advantages: explicit and unambiguous, RFC822-compliant.
   Disadvantage: cumbersome.

   Conclusion: rejected.

4. Use Javadoc-style::

       @Author: Me
       @Version: 1
       @param a: integer

   Advantages: unambiguous, precedent, flexible. Disadvantages:
   non-intuitive, ugly, not RFC822-compliant.

   Conclusion: rejected.

5. Use leading colons::

       :Author: Me
       :Version: 1

   Advantages: unambiguous, obvious (*almost* RFC822-compliant),
   flexible, perhaps even elegant. Disadvantage: no precedent, not
   quite RFC822-compliant.

   Conclusion: accepted!

6. Use double colons::

       Author:: Me
       Version:: 1

   Advantages: unambiguous, obvious? (*almost* RFC822-compliant),
   flexible, similar to syntax already used for literal blocks and
   directives. Disadvantages: no precedent, not quite
   RFC822-compliant, similar to syntax already used for literal blocks
   and directives.

   Conclusion: rejected because of the syntax similarity & conflicts.

Why is RFC822 compliance important? It's a universal Internet
standard, and super obvious. Also, I'd like to support the PEP format
(ulterior motive: get PEPs to use reStructuredText as their standard).
But it *would* be easy to get used to an alternative (easy even to
convert PEPs; probably harder to convert python-deviants ;-).

Unfortunately, without well-defined context (such as in email headers:
RFC822 only applies before any blank lines), the RFC822 format is
ambiguous. It is very common in ordinary text. To implement field
lists unambiguously, we need explicit syntax.

The following question was posed in a footnote:

   Should "bibliographic field lists" be defined at the parser level,
   or at the DPS transformation level? In other words, are they
   reStructuredText-specific, or would they also be applicable to
   another (many/every other?) syntax?

The answer is that bibliographic fields are a
reStructuredText-specific markup convention. Other syntaxes may
implement the bibliographic elements explicitly. For example, there
would be no need for such a transformation for an XML-based markup
syntax.

.. _RFC822: http://www.rfc-editor.org/rfc/rfc822.txt


Interpreted Text "Roles"
========================

The original purpose of interpreted text was as a mechanism for
descriptive markup, to describe the nature or role of a word or
phrase. For example, in XML we could say "<function>len</function>" to
mark up "len" as a function. It is envisaged that within Python
docstrings (inline documentation in Python module source files, the
primary market for reStructuredText) the role of a piece of
interpreted text can be inferred implicitly from the context of the
docstring within the program source. For other applications, however,
the role may have to be indicated explicitly.

Interpreted text is enclosed in single backquotes (`).

1. Initially, it was proposed that an explicit role could be indicated
   as a word or phrase within the enclosing backquotes:

   - As a prefix, separated by a colon and whitespace::

         `role: interpreted text`

   - As a suffix, separated by whitespace and a colon::

         `interpreted text :role`

   There are problems with the initial approach:

   - There could be ambiguity with interpreted text containing colons.
     For example, an index entry of "Mission: Impossible" would
     require a backslash-escaped colon.

   - The explicit role is descriptive markup, not content, and will
     not be visible in the processed output. Putting it inside the
     backquotes doesn't feel right; the *role* isn't being quoted.

2. Tony Ibbs suggested that the role be placed outside the
   backquotes::

       role:`prefix` or `suffix`:role

   This removes the embedded-colons ambiguity, but limits the role
   identifier to be a single word (whitespace would be illegal). Since
   roles are not meant to be visible after processing, the lack of
   whitespace support is not important.

   The suggested syntax remains ambiguous with respect to ratios and
   some writing styles. For example, suppose there is a "signal"
   identifier, and we write::

       ...calculate the `signal`:noise ratio.

   "noise" looks like a role.

3. As an improvement on #2, we can bracket the role with colons::

       :role:`prefix` or `suffix`:role:

   This syntax is similar to that of field lists, which is fine since
   both are doing similar things: describing.

   This is the syntax chosen for reStructuredText.

4. Another alternative is two colons instead of one::

       role::`prefix` or `suffix`::role

   But this is used for analogies ("A:B::C:D": "A is to B as C is to
   D").

   Both alternative #2 and #4 lack delimiters on both sides of the
   role, making it difficult to parse (by the reader).

5. Some kind of bracketing could be used:

   - Parentheses::

         (role)`prefix` or `suffix`(role)

   - Braces::

         {role}`prefix` or `suffix`{role}

   - Square brackets::

         [role]`prefix` or `suffix`[role]

   - Angle brackets::

         <role>`prefix` or `suffix`<role>

     (The overlap of \*ML tags with angle brackets would be too
     confusing and precludes their use.)

Syntax #3 was chosen for reStructuredText.


Comments
========

A problem with comments (actually, with all indented constructs) is
that they cannot be followed by an indented block -- a block quote --
without swallowing it up.

I thought that perhaps comments should be one-liners only. But would
this mean that footnotes, hyperlink targets, and directives must then
also be one-liners? Not a good solution.

Tony Ibbs suggested a "comment" directive. I added that we could limit
a comment to a single text block, and that a "multi-block comment"
could use "comment-start" and "comment-end" directives. This would
remove the indentation incompatibility. A "comment" directive
automatically suggests "footnote" and (hyperlink) "target" directives
as well. This could go on forever! Bad choice.

Garth Kidd suggested that an "empty comment", a ".." explicit markup
start with nothing on the first line (except possibly whitespace) and
a blank line immediately following, could serve as an "unindent". An
empty comment does **not** swallow up indented blocks following it,
so block quotes are safe. "A tiny but practical wart." Accepted.


Anonymous Hyperlinks
====================

Alan Jaffray came up with this idea, along with the following syntax::

    Search the `Python DOC-SIG mailing list archives`{}_.

    .. _: http://mail.python.org/pipermail/doc-sig/

The idea is sound and useful. I suggested a "double underscore"
syntax::

    Search the `Python DOC-SIG mailing list archives`__.

    .. __: http://mail.python.org/pipermail/doc-sig/

But perhaps single underscores are okay? The syntax looks better, but
the hyperlink itself doesn't explicitly say "anonymous"::

    Search the `Python DOC-SIG mailing list archives`_.

    .. _: http://mail.python.org/pipermail/doc-sig/

Mixing anonymous and named hyperlinks becomes confusing. The order of
targets is not significant for named hyperlinks, but it is for
anonymous hyperlinks::

    Hyperlinks: anonymous_, named_, and another anonymous_.

    .. _named: named
    .. _: anonymous1
    .. _: anonymous2

Without the extra syntax of double underscores, determining which
hyperlink references are anonymous may be difficult. We'd have to
check which references don't have corresponding targets, and match
those up with anonymous targets. Keeping to a simple consistent
ordering (as with auto-numbered footnotes) seems simplest.

reStructuredText will use the explicit double-underscore syntax for
anonymous hyperlinks.


Reworking Explicit Markup
=========================

Alan Jaffray came up with the idea of `anonymous hyperlinks`_, added
to reStructuredText. Subsequently it was asserted that hyperlinks
(especially anonymous hyperlinks) would play an increasingly important
role in reStructuredText documents, and therefore they require a
simpler and more concise syntax. This prompted a review of the current
and proposed explicit markup syntaxes with regards to improving
usability.

1. Original syntax::

       .. _blah:                     internal hyperlink target
       .. _blah: http://somewhere    external hyperlink target
       .. _blah: blahblah_           indirect hyperlink target
       .. __: http://somewhere       anonymous external target
       .. __: blahblah_              anonymous indirect target
       .. [blah] http://somewhere    footnote
       .. blah:: http://somewhere    directive
       .. blah: http://somewhere     comment

   Notes on the examples:

   * Anonymous internal targets are also possible, but probably not
     useful, so they're not included.
   * The comment text was intentionally made to look like a hyperlink
     target.

   Origins:

   * Except for the colon (a delimiter necessary to allow for
     phrase-links), hyperlink target ``.. _blah:" comes from Setext.
   * Comment syntax from Setext.
   * Footnote syntax from StructuredText ("named links").
   * Directives and anonymous hyperlinks original to reStructuredText.

   Advantages:

   + Consistent explicit markup indicator: "..".
   + Consistent hyperlink syntax: ".. _" & ":".

   Disadvantages:

   - Anonymous target markup is awkward: ".. __:".
   - The explicit markup indicator ("..") is excessively overloaded?
   - Comment text is limited (can't look like a footnote, hyperlink,
     or directive). But this is probably not important.

2. Alan Jaffray's proposed syntax #1::

       __ _blah                      internal hyperlink target
       __ blah: http://somewhere     external hyperlink target
       __ blah: blahblah_            indirect hyperlink target
       __ http://somewhere           anonymous external target
       __ blahblah_                  anonymous indirect target
       __ [blah] http://somewhere    footnote
       .. blah:: http://somewhere    directive
       .. blah: http://somewhere     comment

   The hyperlink-connoted underscores have become first-level syntax.

   Advantages:

   + Anonymous targets are simpler.
   + All hyperlink targets are one character shorter.

   Disadvantages:

   - Inconsistent internal hyperlink targets. Unlike all other named
     hyperlink targets, there's no colon. There's an extra leading
     underscore, but we can't drop it because without it, "blah" looks
     like a relative URI. Unless we restore the colon::

         __ blah:                      internal hyperlink target

   - Obtrusive markup?

3. Alan Jaffray's proposed syntax #2::

       .. _blah                      internal hyperlink target
       .. blah: http://somewhere     external hyperlink target
       .. blah: blahblah_            indirect hyperlink target
       .. http://somewhere           anonymous external target
       .. blahblah_                  anonymous indirect target
       .. [blah] http://somewhere    footnote
       !! blah: http://somewhere     directive
       ## blah: http://somewhere     comment

   Leading underscores have been (almost) replaced by "..", while
   comments and directives have gained their own syntax.

   Advantages:

   + Anonymous hyperlinks are simpler.
   + Unique syntax for comments. Connotation of "comment" from
     some programming languages (including our favorite).
   + Unique syntax for directives. Connotation of "action!".

   Disadvantages:

   - Inconsistent internal hyperlink targets. Again, unlike all other
     named hyperlink targets, there's no colon. There's a leading
     underscore, matching the trailing underscores of references,
     which no other hyperlink targets have. We can't drop that one
     leading underscore though: without it, "blah" looks like a
     relative URI. Again, unless we restore the colon::

         .. blah:                      internal hyperlink target

   - All (except for internal) hyperlink targets lack their leading
     underscores, losing the "hyperlink" connotation.

   - Obtrusive syntax for comments. Alternatives::

         ;; blah: http://somewhere
            (also comment syntax in Lisp & others)
         ,, blah: http://somewhere
            ("comma comma": sounds like "comment"!)

   - Iffy syntax for directives. Alternatives?

4. Tony Ibbs' proposed syntax::

       .. _blah:                     internal hyperlink target
       .. _blah: http://somewhere    external hyperlink target
       .. _blah: blahblah_           indirect hyperlink target
       .. http://somewhere           anonymous external target
       .. blahblah_                  anonymous indirect target
       .. [blah] http://somewhere    footnote
       .. blah:: http://somewhere    directive
       .. blah: http://somewhere     comment

   This is the same as the current syntax, except for anonymous
   targets which drop their "__: ".

   Advantage:

   + Anonymous targets are simpler.

   Disadvantages:

   - Anonymous targets lack their leading underscores, losing the
     "hyperlink" connotation.
   - Anonymous targets are almost indistinguishable from comments.
     (Better to know "up front".)

5. David Goodger's proposed syntax: Perhaps going back to one of
   Alan's earlier suggestions might be the best solution. How about
   simply adding "__ " as a synonym for ".. __: "? These would become
   equivalent::

       .. __: http://somewhere

       __ http://somewhere

   Would that be sufficient, with no other syntax changes?


Backquotes in Phrase-Links
==========================

[From a 2001-06-05 Doc-SIG post in reply to questions from Doug
Hellmann.]

The first draft of the spec, posted to the Doc-SIG in November 2000,
used square brackets for phrase-links. I changed my mind because:

1. In the first draft, I had already decided on single-backquotes for
   inline literal text.

2. However, I wanted to minimize the necessity for backslash escapes,
   for example when quoting Python repr-equivalent syntax that uses
   backquotes.

3. The processing of identifiers (funtion/method/attribute/module/etc.
   names) into hyperlinks is a useful feature. PyDoc recognizes
   identifiers heuristically, but it doesn't take much imagination to
   come up with counter-examples where PyDoc's heuristics would result
   in embarassing failure. I wanted to do it deterministically, and
   that called for syntax. I called this construct 'interpreted text'.

4. Leveraging off the *emphasis*/**strong** syntax, lead to the idea
   of using double-backquotes as syntax.

5. I worked out some rules for inline markup recognition.

6. In combination with #5, double backquotes lent themselves to inline
   literals, neatly satisfying #2, minimizing backslash escapes. In
   fact, the spec says that no interpretation of any kind is done
   within double-backquote inline literal text; backslashes do *no*
   escaping within literal text.

7. Single backquotes are then freed up for interpreted text.

8. I already had square brackets required for footnote references.

9. Since interpreted text will typically turn into hyperlinks, it was a
   natural fit to use backquotes as the phrase-quoting syntax for
   trailing-underscore hyperlinks.

The original inspiration for the trailing underscore hyperlink syntax
was Setext. But for phrases Setext used a very cumbersome
``underscores_between_words_like_this_`` syntax.

The underscores can be viewed as if they were right-pointing arrows:
'-->'. So ``hyperlink_`` points away from the reference, and
``.. _hyperlink:`` points toward the target.


Inline Substitutions
====================

Inline substitutions arose out of a Doc-SIG thread begun on 2001-10-28
by Alan Jaffray, "reStructuredText inline markup".  It reminded me of
a missing piece of the reStructuredText puzzle, first referred to in
my contribution to "Documentation markup & processing / PEPs" (Doc-SIG
2001-06-21).

Inline substitutions allow the power and flexibility of directives to
be shared by inline text.  They are a way to allow arbitrarily complex
inline objects, while keeping the details out of the flow of text.
They are the equivalent of SGML/XML's named entities.  For example, an
inline image (using inline syntax alternative 3/slashes & substitution
alternative 3, the alternatives chosen for inclusion in the spec)::

    The `/biohazard/` symbol must be used on containers used to
    dispose of medical waste.

    .. /biohazard/ image:: biohazard.png
       [height=20 width=20]

```/biohazard/``` will be replaced in-line by whatever the
``.. /biohazard`` substitution generates (in this case, an image).  A
substitution contains the substitution name, followed by a directive
block containing either replacement text (one paragraph) or a nested
inline-compatible directive, such as "image".  A transform is required
to handle the substitution itself.

Syntax alternatives for the inline part:

1. Use the existing interpreted text syntax, with a predefined role
   such as "sub"::

       The `biohazard`:sub: symbol...

   Advantages: existing syntax, explicit.  Disadvantages: verbose,
   obtrusive.

2. Use a variant of the interpreted text syntax, with a new suffix
   akin to the underscore in phrase-link references::

       `name`@ or `name`# or `name`& or `name`/ or `name`<

   Due to incompatibility with other constructs and ordinary text
   usage, the following are not possible::

       `name`:: and `name`:

3. Use interpreted text syntax with a fixed internal format::

       `:name:` or `name:` or `name::` or `::name::` or `%name%` or
       `#name#` or `/name/` or `&name&` or even `<name>` or `&name;`

   (To avoid ML confusion those last two are definitely out.)

   The ```/name/``` syntax is reminiscent of substitution.

4. Use specialized syntax, something new::

       #name# or @name@ or /name/ or...

   "#" and "@" are obtrusive.  "/" without backquotes looks just like
   a POSIX path; it is likely for such usage to appear in text.

Syntax alternatives for the substitution part::

1. Use the existing directive syntax, with a predefined directive
   such as "sub".  It contains either replacement text or another
   directive resolving to an inline-compatible object::

       .. sub:: biohazard
          .. image:: biohazard.png
             [height=20 width=20]

       .. sub:: parrot
          That bird wouldn't *voom* if you put 10,000,000 volts
          through it!

   The advantages and disadvantages are the same as in inline
   alternative 1.

2. Use syntax as in #1, but compressed.  If the substitution contents
   is a directive, append it to the substitution directive marker::

       .. sub:: biohazard image:: biohazard.png
          [height=20 width=20]

   Replacement text could also be (optionally) compressed::

       .. sub:: parrot That bird wouldn't *voom* if you put
          10,000,000 volts through it!

   This is a bit better than alternative 1, but still too much.

3. Use a variant of directive syntax, incorporating the substitution
   name, obviating the need for a special "sub" directive name.  If we
   assume inline alternative 3 (slashes), the matching substitutions
   would look like this::

       .. /biohazard/ image:: biohazard.png
          [height=20 width=20]

       .. /parrot/ That bird wouldn't *voom* if you put
          10,000,000 volts through it!

   There is potential conflict with short paths in comments, but
   that can be safely ignored.

The syntax that seems most consistent and suggestive of its intended
purpose is the combination of inline alternative 3/slashes with
substitution alternative 3::


    The `/biohazard/` symbol...

    .. /biohazard/ image:: biohazard.png
       [height=20 width=20]

We can also combine substitution references with hyperlink references,
by appending a "_" (named hyperlink reference) or "__" (anonymous
hyperlink reference) suffix to the substitution reference.  This
allows us to click on an image-link::

    The `/biohazard/`_ symbol...

    .. /biohazard/ image:: biohazard.png
       [height=20 width=20]
    .. _biohazard: http://www.cdc.gov/

This syntax has been incorporated into the spec and parser.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
